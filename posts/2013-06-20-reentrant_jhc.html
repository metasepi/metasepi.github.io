<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Shape reentrant on Ajhc. - Metasepi</title>

  <meta name="description" content="metasepi.org">
  <meta name="author" content="Kiwamu Okabe">

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="http://metasepi.org/rss_en.xml" rel="alternate" title="Blog" type="application/rss+xml">

  <!-- CSS concatenated and minified via ant build script-->
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/syntax.css">
  <link rel="stylesheet" href="../css/calendar.css">
  <!-- end CSS-->

  <link rel="stylesheet" href="../css/default.css">

  <script src="../js/libs/modernizr-2.0.6.min.js"></script>
</head>

<body onload="prettyPrint()">
  <div id="fb-root"></div>
  <script>
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) {return;}
      js = d.createElement(s); js.id = id;
      js.src = '//connect.facebook.net/ja_JP/all.js#xfbml=1';
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>

  <header class="topbar">
    <div class="container">
      <div class="brand">
        <a href="../">Metasepi</a>
      </div>

      <div class="nav">
        <li><a href="../">Home</a></li>
        <li><a href="../en/posts.html">Blog</a>(<a href="../posts.html">old</a>)</li>
        <li><a href="../papers.html">Papers</a></li>
        <li><a href="../map.html">Map</a></li>
        <li><a href="../memories.html">Memories</a></li>
        <li><a href="../about.html">About</a></li>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="content clearfix">
      <h1>Shape reentrant on Ajhc.</h1>
<div class="info">Posted on June 20, 2013 / Tags: <a href="../tags/jhc.html">jhc</a>, <a href="../tags/ajhc.html">ajhc</a>, <a href="../tags/reentrant.html">reentrant</a>, <a href="../tags/interrupt.html">interrupt</a>, <a href="../tags/lock.html">lock</a></div>
<h2>Table of contents</h2>
<ul>
<li><a href="#スナッチ対象を決めるでゲソ">スナッチ対象を決めるでゲソ</a></li>
<li><a href="#設計方針">設計方針</a></li>
<li><a href="#foreign-export-ccallはajhcでも使えるか">foreign export ccallは(A)jhcでも使えるか</a></li>
<li><a href="#gcスタックとhaskellヒープのコンテキストへの割り当てと解放">GCスタックとHaskellヒープのコンテキストへの割り当てと解放</a><ul>
<li><a href="#コンパイルパイプラインを修正してforeign-export-ccallの入口出口でgcスタックとhaskellヒープの割り当て解放">コンパイルパイプラインを修正してforeign export ccallの入口/出口でGCスタックとHaskellヒープの割り当て/解放</a></li>
<li><a href="#使用済みgcスタックとhaskellヒープを次回確保用にプール">使用済みGCスタックとHaskellヒープを次回確保用にプール</a></li>
<li><a href="#ランタイムのapi修正">ランタイムのAPI修正</a></li>
</ul></li>
<li><a href="#ajhcに求められる排他制御とは何か">Ajhcに求められる排他制御とは何か</a><ul>
<li><a href="#グローバルサンクの評価での排他とblackhole">グローバルサンクの評価での排他とBLACKHOLE</a></li>
<li><a href="#シグナルハンドラはsigwaitで取り扱う">シグナルハンドラはsigwaitで取り扱う</a></li>
</ul></li>
<li><a href="#モジュール分割">モジュール分割</a><ul>
<li><a href="#ghcで該当するapi">GHCで該当するAPI</a></li>
<li><a href="#haskell側に公開するapi">Haskell側に公開するAPI</a></li>
<li><a href="#ランタイム側で準備するapi">ランタイム側で準備するAPI</a></li>
</ul></li>
<li><a href="#あとは実装するだけじゃなイカ">あとは実装するだけじゃなイカ!</a></li>
<li><a href="#実験-pthreadを使ってtimingdelayをエミュレートしてみる">実験: pthreadを使ってTimingDelayをエミュレートしてみる</a></li>
</ul>
<hr>
<p>いきなりAjhcの吐くコードを並列実行可能にすることはハードルが高すぎるでゲソ。 まず再入可能を実現しなイカ？</p>
<h2 id="スナッチ対象を決めるでゲソ">スナッチ対象を決めるでゲソ</h2>
<p>再入可能を実現するにあたって、何かアプリケーション例があった方が良いでゲソ。 <a href="https://github.com/ajhc/demo-cortex-m3">Cortex-M3向けデモ</a> の中にイカのようなコードがあるでゲソ。</p>
<div class="sourceCode"><pre class="sourceCode gnuassembler"><code class="sourceCode gnuassembler"><span class="co">/* File: demo-cortex-m3/stm32f3-discovery/Device/startup_stm32f30x.s */</span>
 	<span class="kw">.section</span>	.isr_vector,<span class="st">&quot;a&quot;</span>,%progbits
	<span class="kw">.type</span>	g_pfnVectors, %object
	<span class="kw">.size</span>	g_pfnVectors, .-g_pfnVectors

<span class="kw">g_pfnVectors:</span>
	<span class="kw">.word</span>	_estack
	<span class="kw">.word</span>	Reset_Handler
<span class="co">/* snip */</span>
	<span class="kw">.word</span>	PendSV_Handler
	<span class="kw">.word</span>	SysTick_Handler</code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// File: demo-cortex-m3/stm32f3-discovery/src/main.c</span>
__IO <span class="dt">uint32_t</span> TimingDelay = <span class="dv">0</span>;

<span class="dt">void</span> SysTick_Handler(<span class="dt">void</span>)
{
  TimingDelay_Decrement();
}

<span class="dt">void</span> TimingDelay_Decrement(<span class="dt">void</span>)
{
  <span class="cf">if</span> (TimingDelay != <span class="bn">0x00</span>)
  { 
    TimingDelay--;
  }
}

<span class="dt">void</span> Delay(__IO <span class="dt">uint32_t</span> nTime)
{
  TimingDelay = nTime;

  <span class="cf">while</span>(TimingDelay != <span class="dv">0</span>);
}</code></pre></div>
<p>このしくみはDelay関数による指定時間待ち合わせを実現するために、イカのような動作を期待しているでゲソ。</p>
<ol style="list-style-type: decimal">
<li>Delay関数呼び出し</li>
<li>Delay関数はグローバル変数TimingDelayに待ち時間を代入</li>
<li>Delay関数はそのままTimingDelayが0になるのを待つ</li>
<li>クロック割り込みでSysTick_Handler関数が起動される</li>
<li>SysTick_Handler関数はTimingDelayを1減ずる</li>
<li>4と5が繰り返されるとそのうちTimingDelayが0になる</li>
<li>3の待ちが解除される</li>
</ol>
<p>上記コードをHaskell化してみなイカ？</p>
<h2 id="設計方針">設計方針</h2>
<p>設計の方針に大きく影響するのはHaskellヒープの確保でゲソ。これは大きく2つの案に分かれるでゲソ。</p>
<ul>
<li>A. 実行バイナリの中でHaskellヒープは唯一一つだけ確保する
<ul>
<li>メリット: STMなどコンテキスト間での状態共有を実装しやすい</li>
<li>デメリット: ミューテターのクリティカルリージョン保護を実装する必要がある。場合によってはjgcの抜本的見直しが必要</li>
</ul></li>
<li>B. Haskellヒープをコンテキスト毎に分割して持つ
<ul>
<li>メリット: jgcのGCスタックをそのまま適用できる。GCコストがコンテキストの規模に比例する。並列実行できる</li>
<li>デメリット: コンテキスト間での状態共有には完全に正格なデータでなければならないなど制限がかる。設計者が意図しない所でサンクが共有されてしまう可能性</li>
</ul></li>
</ul>
<p>通常はAの方が良い案でゲソ。GHCも案Aを採用しているじゃなイカ。 しかしAjhcではミューテターが生C言語である関係上、 明示的なコンテキストスイッチをミューテター側から判断させるのかきびしいでゲソ。 さらに将来NetBSD kernelをスナッチすることも考えると、 RTSを頻繁に呼び出すような息継ぎをミューテターにさせるのはナンセンスとしか思えないでゲソ。</p>
<p>案Bに関して考えると思わぬメリットあり、 それはコンテキスト間でGC関連の処理を完全に分離できるということでゲソ。 つまり並列にGCさせることももちろんできるでゲソ。 さらにHaskellヒープをどれぐらい汚すかはコンテキストによって決まるので、 ヒープを汚したコンテキストが自分でお掃除する責務を負うのでコンテキスト毎のGC負荷が予測しやすいでゲソ。 kernelのほとんどの部分はイベントドリブンであることを考えると、 世代別GCを作らなくても乗り切れるかもしれないじゃなイカ。</p>
<p>案Bの問題はコンテキスト間の状態共有でゲソが、 プリミティブ型へのPtr型を使う分には何も問題にはならないでゲソ。 もちろんサンクが知らぬ間にコンテキスト間で共有されてしまうケースも考えられるでゲソ。 さらにSTMような複雑な状態共有方法についてはどうすれば解決するのか検討もつかないじゃなイカ。 しかし案Aより案Bの方が実装コストが低いことは容易に想像できるので、 まずは案Bで実装してみなイカ？ 実装してみてgrinコードを眺めてみればまたアイデアがわくかもしれないでゲソ。</p>
<p>というわけで設計方針はなんとなくイカに分解できそうでゲソ。</p>
<ul>
<li>TimingDelay変数はPtr Word32型に</li>
<li>SysTick_Handler関数はforeign export ccall SysTick_Handler :: IO ()</li>
<li>foreign export ccallな関数は呼び出される度にGCスタックとヒープを割り当て</li>
<li>foreign export ccallな関数が終了したら自GCスタックとヒープを解放</li>
<li>GCスタック毎に別々のHaskellヒープを持つ</li>
<li>s_alloc関数はコンテキストによって使うヒープを切り換え</li>
<li>GC関連関数の実行を排他するためのロックプリミティブ</li>
</ul>
<p>それぞれについて実施できそうか調べてみようじゃなイカ。</p>
<h2 id="foreign-export-ccallはajhcでも使えるか">foreign export ccallは(A)jhcでも使えるか</h2>
<p>Main.main関数がないとコンパイルエラーになるでゲソが、いちおう使えるでゲソ。 <a href="https://github.com/master-q/SlimHaskell/tree/master/FibHs_ajhc">SlimHaskell/FibHs_ajhc</a> にソースコードとコンパイル済みバイナリを置いたでゲソ。</p>
<pre><code>$ size */FibHs | sort -n -k 6
   text    data     bss     dec     hex filename
  13527    1224     712   15463    3c67 FibHs_ajhc/FibHs
 285321   11048   26088  322457   4eb99 FibHs13/FibHs
 303321   12416   26088  341825   53741 FibHs12/FibHs
 415297   27152   26080  468529   72631 FibHs11/FibHs
 719915   73896   26080  819891   c82b3 FibHs10/FibHs
 809675   81128   26080  916883   dfd93 FibHs9/FibHs
1102459  108864   26080 1237403  12e19b FibHs8/FibHs
1316273  128520   26496 1471289  167339 FibHs7/FibHs
1662383  134296   42880 1839559  1c11c7 FibHs6/FibHs
1704127  134856   44088 1883071  1cbbbf FibHs5/FibHs
2503048  266320   44088 2813456  2aee10 FibHs4/FibHs
2523847  266616   44088 2834551  2b4077 FibHs3/FibHs
2719976  282776   44088 3046840  2e7db8 FibHs2/FibHs
2780783  290568   45592 3116943  2f8f8f FibHs1/FibHs
2784294  290592   47960 3122846  2fa69e FibHs0/FibHs</code></pre>
<p>ところでjhcの威力はすごいでゲソ。 <a href="http://www.paraiso-lang.org/ikmsm/books/c83.html">簡約! λカ娘(4)</a> でGHCあれだけがんばったサイズ削減結果よりはるかに小さいバイナリを吐くでゲソ。 すごいじゃなイカ!</p>
<h2 id="gcスタックとhaskellヒープのコンテキストへの割り当てと解放">GCスタックとHaskellヒープのコンテキストへの割り当てと解放</h2>
<h3 id="コンパイルパイプラインを修正してforeign-export-ccallの入口出口でgcスタックとhaskellヒープの割り当て解放">コンパイルパイプラインを修正してforeign export ccallの入口/出口でGCスタックとHaskellヒープの割り当て/解放</h3>
<p>foreign export ccallがgrinの中でどう扱われているのか気になったので、 foreign export ccallを使うHaskellコードを<a href="https://github.com/ajhc/ajhc-dumpyard/tree/master/use_foreign_export">ダンプしてみた</a>でゲソ。 このダンプの中にあるgrinコード <a href="https://github.com/ajhc/ajhc-dumpyard/blob/master/use_foreign_export/hs_main.c_final.grin">hs_main.c_final.grin</a></p>
<pre><code>fFE@.CCall.fib :: (bits32) -&gt; (bits32)
fFE@.CCall.fib w8 = do
  h100016 &lt;- 0 `Lte` w8
  nd68 &lt;- case h100016 of
    0 -&gt; return (CJhc.Type.Word.Int 0)
    1 -&gt; do
      h100018 &lt;- 40 `Gte` w8
      case h100018 of
        1 -&gt; do</code></pre>
<p>と出力されたC言語コード <a href="https://github.com/ajhc/ajhc-dumpyard/blob/master/use_foreign_export/hs_main.c">hs_main.c</a></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">uint32_t</span> A_STD
fFE$__CCall_fib(gc_t gc,<span class="dt">uint32_t</span> v8)
{
        wptr_t v68;
        <span class="dt">uint32_t</span> v35;
        <span class="dt">uint16_t</span> v100016 = (((<span class="dt">int32_t</span>)<span class="dv">0</span>) &lt;= ((<span class="dt">int32_t</span>)v8));
        <span class="cf">if</span> (<span class="dv">0</span> == v100016) {
<span class="co">/* --snip-- */</span>
<span class="dt">int</span> 
fib(<span class="dt">int</span> x11)
{
        <span class="cf">return</span> (<span class="dt">int</span>)fFE$__CCall_fib(saved_gc,(<span class="dt">uint32_t</span>)x11);
}</code></pre></div>
<p>を見比べると、どうやら“fFE$__CCall_fib“という関数がforeign export ccallした関数のようでゲソ。 また <a href="https://github.com/ajhc/ajhc-dumpyard/blob/master/use_foreign_export/hs_main.c_final.datalog">hs_main.c_final.datalog</a> を読むとイカのように型の定義まであるじゃなイカ。</p>
<pre><code>% functions
-- snip --
func('fFE@.CCall.fib',1).
perform(assign,'v8','fFE@.CCall.fib@arg@0').
what('fFE@.CCall.fib@arg@0',funarg).
typeof('fFE@.CCall.fib@arg@0','bits32').
typeof('v8','bits32').
what('fFE@.CCall.fib@ret@0',funret).
typeof('fFE@.CCall.fib@ret@0','bits32').
-- snip --
subfunc('fW@.fR@.fJhc.List.243_sub','fFE@.CCall.fib').
-- snip --
perform(assign,'fFE@.CCall.fib@ret@0','v35').</code></pre>
<p>このforeign export ccallな関数はgrinの中ではそのまんまCCallという型で表現されているでゲソ。 ということはイカのconvertFunc関数を修正すれば、 GCスタックとHaskellヒープの割り当て/解放処理をforeign export ccallな関数に注入できそうじゃなイカ。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ajhc/src/C/FFI.hs</span>
<span class="kw">data</span> <span class="dt">FfiExport</span> <span class="fu">=</span> <span class="dt">FfiExport</span> {
<span class="ot">    ffiExportCName    ::</span> <span class="dt">CName</span>,
<span class="ot">    ffiExportSafety   ::</span> <span class="dt">Safety</span>,
<span class="ot">    ffiExportCallConv ::</span> <span class="dt">CallConv</span>,
<span class="ot">    ffiExportArgTypes ::</span> [<span class="dt">ExtType</span>],
<span class="ot">    ffiExportRetType  ::</span> <span class="dt">ExtType</span>
    }
 <span class="kw">deriving</span>(<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Typeable</span>)
<span class="co">-- ajhc/src/C/Prims.hs</span>
<span class="kw">data</span> <span class="dt">CallConv</span> <span class="fu">=</span> <span class="dt">CCall</span> <span class="fu">|</span> <span class="dt">StdCall</span> <span class="fu">|</span> <span class="dt">CApi</span> <span class="fu">|</span> <span class="dt">Primitive</span> <span class="fu">|</span> <span class="dt">DotNet</span>
    <span class="kw">deriving</span>(<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)
<span class="co">-- ajhc/src/C/FromGrin2.hs</span>
<span class="ot">convertFunc ::</span> <span class="dt">Maybe</span> <span class="dt">FfiExport</span> <span class="ot">-&gt;</span> (<span class="dt">Atom</span>,<span class="dt">Lam</span>) <span class="ot">-&gt;</span> <span class="dt">C</span> [<span class="dt">Function</span>]
convertFunc ffie (n,as <span class="fu">:-&gt;</span> body) <span class="fu">=</span> <span class="kw">do</span>
<span class="co">--snip--</span>
        mstub <span class="ot">&lt;-</span> <span class="kw">case</span> ffie <span class="kw">of</span>
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return []
                <span class="dt">Just</span> <span class="fu">~</span>(<span class="dt">FfiExport</span> cn <span class="dt">Safe</span> <span class="dt">CCall</span> argTys retTy) <span class="ot">-&gt;</span> <span class="kw">do</span>
                    newVars <span class="ot">&lt;-</span> mapM (liftM (name <span class="fu">.</span> show) <span class="fu">.</span> newVar <span class="fu">.</span> basicType') argTys

                    <span class="kw">let</span> fnname2 <span class="fu">=</span> name cn
                        as2 <span class="fu">=</span> zip (newVars) (map basicType' argTys)
                        fr2 <span class="fu">=</span> basicType' retTy

                    return [function fnname2 fr2 as2 [<span class="dt">Public</span>]
                                     (creturn <span class="fu">$</span> cast fr2 <span class="fu">$</span> functionCall fnname <span class="fu">$</span> (<span class="kw">if</span> fopts <span class="dt">FO.Jgc</span> <span class="kw">then</span> (variable (name <span class="st">&quot;saved_gc&quot;</span>)<span class="fu">:</span>) <span class="kw">else</span> id) <span class="fu">$</span>
                                      zipWith cast (map snd as')
                                                   (map variable newVars))]

        return (function fnname fr (mgct as') ats s <span class="fu">:</span> mstub)</code></pre></div>
<h3 id="使用済みgcスタックとhaskellヒープを次回確保用にプール">使用済みGCスタックとHaskellヒープを次回確保用にプール</h3>
<p>今のAjhcは通常イカのようにGCスタックとHaskellヒープを管理しているでゲソ。</p>
<ul>
<li>GCスタック: mallocで確保。サイズは1&lt;&lt;18エントリ</li>
<li>Haskellヒープ: 1MBずつmegablockが補給される</li>
</ul>
<p>“_JHC_JGC_FIXED_MEGABLOCK&quot; defineが有効な場合、 GCスタックとHaskellヒープはどちらも固定サイズで唯一一つだけ確保されるのだったでゲソ。 少し冗長になるでゲソが、Cortex-M4に対応するにはイカのコンパイルフラグが必要になりそうでゲソ。</p>
<ul>
<li>“_JHC_JGC_GCSTACK_SIZE“: GCスタックのサイズ指定</li>
<li>“_JHC_JGC_FIXEDNUM_GCSTACK“: GCスタックの個数(個数限定)</li>
<li>“_JHC_JGC_MEGABLOCK_SHIFT“: megablockのサイズ指定</li>
<li>“_JHC_JGC_BLOCK_SHIFT“: blockのサイズ指定</li>
<li>“_JHC_JGC_FIXEDNUM_MEGABLOCK“: megablockの個数(個数限定)</li>
</ul>
<p>“_JHC_JGC_FIXED_MEGABLOCK“フラグは意味が変更になってしまうので撤廃するでゲソ。</p>
<p>また、GCスタックとHaskellヒープを動的に確保する場合も固定で確保する場合も Ajhcランタイム内部のリストにプールしておき、 要求された時にmallocを呼ばずにミューテターに渡せるようにしたいでゲソ。 GCスタックもmegablockも一つのエントリは固定サイズなので、 見分けがつかないはずでゲソ。</p>
<h3 id="ランタイムのapi修正">ランタイムのAPI修正</h3>
<p>今回の変更でstruct s_arenaを文脈毎に分割して持つことになるでゲソ。 そこで、AjhcランタイムのAPIもそれに合わせて修正が必要になるでゲソ。</p>
<ul>
<li>struct s_arenaを全ての関数の第二引数でひきまわす (第一引数はGCスタックへのポインタ)</li>
<li>struct s_arenaにgc_stack_baseメンバーを追加 (saved_gcメンバーも必要？)</li>
<li>ミューテターから呼び出される関数の引数にstruct s_arenaを追加、そのような関数は…
<ul>
<li>eval</li>
<li>gc_add_root</li>
<li>gc_alloc</li>
<li>gc_array_alloc</li>
<li>gc_array_alloc_atomic</li>
<li>gc_perform_gc</li>
<li>s_alloc</li>
</ul></li>
</ul>
<p>gc_new_foreignptrとかは対応しなくていいんだろうかちょっと不安でゲソ</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- File: ajhc/lib/jhc/Jhc/ForeignPtr.hs</span>
foreign <span class="kw">import </span>safe ccall gc_malloc_foreignptr
<span class="ot">    ::</span> <span class="dt">Word</span>     <span class="co">-- alignment in words</span>
    <span class="ot">-&gt;</span> <span class="dt">Word</span>     <span class="co">-- size in words</span>
    <span class="ot">-&gt;</span> <span class="dt">Bool</span>     <span class="co">-- false for plain foreignptrs, true for ones with finalizers.</span>
    <span class="ot">-&gt;</span> <span class="dt">UIO</span> (<span class="dt">Bang_</span> (<span class="dt">ForeignPtr</span> a))

foreign <span class="kw">import </span>safe ccall gc_new_foreignptr ::
    <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">UIO</span> (<span class="dt">Bang_</span> (<span class="dt">ForeignPtr</span> a))

foreign <span class="kw">import </span>unsafe ccall gc_add_foreignptr_finalizer
<span class="ot">    ::</span> <span class="dt">Bang_</span> (<span class="dt">ForeignPtr</span> a)
    <span class="ot">-&gt;</span> <span class="dt">FinalizerPtr</span> a
    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>と、GCスタックへのポインタを渡していないライブラリがあるでゲソ。 そしてランタイムのGC側ではグローバル変数saved_gcからGCスタックを取り出しているでゲソ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* File: ajhc/rts/rts/gc_jgc.c */</span>
heap_t A_STD
gc_new_foreignptr(HsPtr ptr) {
        HsPtr *res = gc_array_alloc_atomic(saved_gc, <span class="dv">2</span>, SLAB_FLAG_FINALIZER);
        res[<span class="dv">0</span>] = ptr;
        res[<span class="dv">1</span>] = NULL;
        <span class="cf">return</span> TO_SPTR(P_WHNF, res);
}</code></pre></div>
<p>このように一旦GCスタックへのポインタの受け渡しが途切れる箇所がいくつかあり、それは</p>
<ul>
<li>gc_malloc_foreignptr</li>
<li>gc_new_foreignptr</li>
<li>hs_perform_gc</li>
<li>jhc_alloc_init</li>
</ul>
<p>の4つのようでゲソ。これはまずいでゲソ… なんとかstruct arenaとGCスタックへのポインタを渡せるようにすべきでゲソ。 もっと踏み込むと“foreign import ccall”にGCスタックを渡すことを指定する修飾子が必要でゲソ。</p>
<h2 id="ajhcに求められる排他制御とは何か">Ajhcに求められる排他制御とは何か</h2>
<p>Cortex-M3ぐらいの小さなCPUではロックを作らなくても、割り込み禁止でいいんじゃなイカ？ とはいえユーザ空間でも動かせるように排他制御を抽象化しておいた方がいいでゲソ。 現時点での排他したいモノは…</p>
<ul>
<li>mallocヒープへの操作</li>
<li>GCスタックとHaskellヒープの管理プールへの操作</li>
</ul>
<p>排他の実現手段は…</p>
<ul>
<li><a href="http://netbsd.gw.com/cgi-bin/man-cgi?pthread_mutex_lock++NetBSD-current">pthread_mutex_lock</a></li>
<li><a href="http://netbsd.gw.com/cgi-bin/man-cgi?mutex_enter++NetBSD-current">NetBSD mutex_enter</a></li>
<li>CASを使ったシンプルなロック</li>
<li>割り込み禁止 (今はCortex-M3のみ)</li>
<li>ノーガード戦法</li>
</ul>
<p>条件変数 (<a href="http://netbsd.gw.com/cgi-bin/man-cgi?pthread_cond_wait++NetBSD-current">pthread_cond_wait</a> や <a href="http://netbsd.gw.com/cgi-bin/man-cgi?condvar++NetBSD-current">NetBSD cv_wait</a>) が将来必要になることはないのかちょっと予測しきれないでゲソ… 不要ということおそらくないのでAPIの名前空間としては使用可能にした方がいいんじゃなイカ？ 具体的なインターフェイスはイカの3つで今回のケースは充足するでゲソ。</p>
<ul>
<li>ロックの初期化</li>
<li>lock</li>
<li>unlock</li>
</ul>
<p>ロックの解放はむつかしい問題でゲソが、今回はロックの解放はプロセスの終了と同時で問題ないでゲソ。</p>
<h3 id="グローバルサンクの評価での排他とblackhole">グローバルサンクの評価での排他とBLACKHOLE</h3>
<p>アドレスnh_startからnh_endまでの領域にはグローバルサンクが配置されているでゲソ。 少なくともグローバルサンクは複数のコンテキストで共有するので、なにか排他をするべきじゃなイカ？</p>
<h3 id="シグナルハンドラはsigwaitで取り扱う">シグナルハンドラはsigwaitで取り扱う</h3>
<p>mutex_enterはkernelの割り込みハンドラから使用可能でゲソが、 pthread_mutex_lockはシグナルハンドラから使用することができないでゲソ。 そこで、POSIXのmutexを使う場合にはシグナル処理専用のスレッドを起こして、 sigwaitループさせた方が良さそうでゲソ。</p>
<h2 id="モジュール分割">モジュール分割</h2>
<p>先に見た通り、ロックを提供する手段にはいろいろあるでゲソ。 どの手段が最適ということはなく、Ajhcを適用するドメイン毎にロックの実現手段は選択できた方が良いでゲソ。 そこで、ロック関連の機能を提供するモジュールをHaskellライブラリ化して、 そのモジュールのAPIをHaskell側とランタイム側双方から使うようにするでゲソ。 そのライブラリの種別はイカの3つにするでゲソ。</p>
<ul>
<li>空実装 (デフォルト)</li>
<li>pthreadによる実装</li>
<li>実装なし (コンパイラ使用者が独自に実装)</li>
</ul>
<p>このモジュールの公開APIを考えてみるでゲッソ! ところでajhc/src/StringTable/StringTable_cbits.cにpthread_mutex_lock が入っているでゲソが、USE_THREADSが0になっていて殺されているでゲソ… 今回コイツも復活させてやった方がいいんじゃなイカ？ SelfTestがたまに失敗する原因はこいつなような気がしてきたでゲッソ。</p>
<h3 id="ghcで該当するapi">GHCで該当するAPI</h3>
<p>せっかくAPIを切るのだからGHCと同じ名前にしておいた方が後々楽ができるんじゃなイカ？</p>
<ul>
<li>type Signal = CInt</li>
<li>setHandler :: Signal -&gt; Maybe (HandlerFun, Dynamic) -&gt; IO (Maybe (HandlerFun, Dynamic))</li>
<li>int stg_sig_install(int sig, int spi, void *mask)</li>
<li>forkOS :: IO () -&gt; IO ThreadId</li>
<li>int forkOS_createThread ( HsStablePtr entry )</li>
<li>typedef pthread_mutex_t Mutex</li>
<li>void initMutex ( Mutex* pMut )</li>
<li>#define ACQUIRE_LOCK(mutex) foreign “C” pthread_mutex_lock(mutex)</li>
<li>#define RELEASE_LOCK(mutex) foreign “C” pthread_mutex_unlock(mutex)</li>
</ul>
<p>書きだしたけれど、とりあえず今はスレッドが扱えれば良いので、シグナルの抽象化はやめておこうと思うでゲソ。 ということでこのGHCのAPIを真似てAjhcでの公開APIを決めるでゲソ〜。</p>
<h3 id="haskell側に公開するapi">Haskell側に公開するAPI</h3>
<ul>
<li>data ThreadId</li>
<li>forkOS :: IO () -&gt; IO ThreadId</li>
</ul>
<h3 id="ランタイム側で準備するapi">ランタイム側で準備するAPI</h3>
<ul>
<li>typedef pthread_t jhc_threadid_t</li>
<li>typedef pthread_mutex_t jhc_mutex_t</li>
<li>void jhc_mutex_init(jhc_mutex_t *mutex)</li>
<li>void jhc_mutex_lock(jhc_mutex_t *mutex)</li>
<li>void jhc_mutex_unlock(jhc_mutex_t *mutex)</li>
<li>jhc_threadid_t forkOS_createThread(void <em>(</em>wrapper) (void <em>), void </em>entry, int *err);</li>
<li>void jhc_conc_init(void);</li>
<li>void jhc_rts_lock(void);</li>
<li>void jhc_rts_unlock(void);</li>
</ul>
<h2 id="あとは実装するだけじゃなイカ">あとは実装するだけじゃなイカ!</h2>
<p>これまではgcが全ての関数の第一引数になっていたじゃなイカ。 さらに <a href="https://github.com/ajhc/ajhc/commit/4f8a185bace5562e16fb9fb803a8db9d43578d54">arenaを全ての関数の第二引数に追加</a> したでゲソ。 この対応でgcとarenaをコンテキスト毎に別々に取ることができ、GCをコンテキストローカルで実行できるようになったでゲソ。</p>
<p>またsaved_gcというグローバル変数でFFIによるC言語関数実行の前にgcの中断をメモしていたでゲソが、 イカの3つの関数だけgcとarenaを直接RTSに渡すようにすればこのsaved_gcは不要になるはずでゲソ。</p>
<pre><code>$ git grep import lib|grep &quot; safe&quot;
lib/jhc/Jhc/ForeignPtr.hs:foreign import safe ccall gc_malloc_foreignptr
lib/jhc/Jhc/ForeignPtr.hs:foreign import safe ccall gc_new_foreignptr ::
lib/jhc/System/Mem.hs:foreign import ccall safe &quot;hs_perform_gc&quot; performGC :: IO ()</code></pre>
<p><a href="https://github.com/ajhc/ajhc/commit/889d2cf5d557b9d5b41a318efa8237d487de4142">foreign import jhc_context ccall</a> というAjhc専用のimport種別を作成して、この種別が有効な場合にはC言語の関数にgcとarenaを引数渡しするようになったでゲソ。</p>
<p>ところで <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch8.html">Haskell 2010: 8 Foreign Function Interface</a> によると、hs_perform_gc関数には引数を取れない決まりでゲソ。 するとRTSをロックして次回s_alloc時にGCを実行するようなフラグをarenaに立ててやる必要がありそうでゲソ。 とりあえず生存しているコンテキストに対応するarenaに対して <a href="https://github.com/ajhc/ajhc/commit/fe31a9dd047ed0a564955a51ff51582f05f08b1f#L1L715">次回s_alloc呼び出しの際に強制GC実行</a> するようにしてみたでゲソ。</p>
<p>さらにs_cacheがグローバル管理されているのもなんとかしたいでゲソ。 s_cacheの定義を新規structにまとめて、arenaの下にそのstructを配置すればなんとかなりそうじゃなイカ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* File: ajhc/rts/rts/gc_jgc_internal.h */</span>
<span class="kw">struct</span> s_cache {
        SLIST_ENTRY(s_cache) next;
        SLIST_HEAD(,s_block) blocks;
        SLIST_HEAD(,s_block) full_blocks;
        <span class="dt">unsigned</span> <span class="dt">char</span> color;
        <span class="dt">unsigned</span> <span class="dt">char</span> size;
        <span class="dt">unsigned</span> <span class="dt">char</span> num_ptrs;
        <span class="dt">unsigned</span> <span class="dt">char</span> flags;
        <span class="dt">unsigned</span> <span class="dt">short</span> num_entries;
        <span class="kw">struct</span> s_arena *arena;
<span class="pp">#if _JHC_PROFILE</span>
        <span class="dt">unsigned</span> allocations;
<span class="pp">#endif</span>
};

<span class="co">/* File: hs_main.c */</span>
<span class="pp">#include </span><span class="im">&quot;jhc_rts_header.h&quot;</span>
<span class="dt">static</span> <span class="kw">struct</span> s_cache *cCJhc_Prim_Prim_$x3a;
<span class="dt">static</span> <span class="kw">struct</span> s_cache *cCJhc_Type_Basic_Just;
<span class="co">/* snip */</span>
<span class="dt">void</span> 
jhc_hs_init(<span class="dt">void</span>)
{
        find_cache(&amp;cCJhc_Prim_Prim_$x3a,saved_arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a)),<span class="dv">2</span>);
        find_cache(&amp;cCJhc_Type_Basic_Just,saved_arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Type_Basic_Just)),<span class="dv">1</span>);
<span class="co">/* snip */</span>
                    sptr_t v69834446 = MKLAZY(x6);
                    {   gc_frame0(gc,<span class="dv">1</span>,v69834446);
                        wptr_t x7 = s_alloc(gc,arena,cCJhc_Prim_Prim_$x3a);
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x7)-&gt;a1 = v106;
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x7)-&gt;a2 = v69834446;
                        <span class="cf">return</span> x7;</code></pre></div>
<p>同様にランタイムにあるグローバルs_cacheも <a href="https://github.com/ajhc/ajhc/commit/2c898ff294f93a6bbd6ad58c7dc26ab2aa87d8d4">arenaの下に移動</a> したでゲソ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* File: ajhc/rts/rts/gc_jgc.c */</span>
<span class="co">// 7 to share caches with the first 7 tuples</span>
<span class="pp">#define GC_STATIC_ARRAY_NUM 7</span>
<span class="pp">#define GC_MAX_BLOCK_ENTRIES 150</span>

<span class="dt">static</span> <span class="kw">struct</span> s_cache *array_caches[GC_STATIC_ARRAY_NUM];
<span class="dt">static</span> <span class="kw">struct</span> s_cache *array_caches_atomic[GC_STATIC_ARRAY_NUM];</code></pre></div>
<h2 id="実験-pthreadを使ってtimingdelayをエミュレートしてみる">実験: pthreadを使ってTimingDelayをエミュレートしてみる</h2>
<p>ハードウェア割り込みのエミュレートなので、forkOSは使わないでゲソがとにかくやってみるでゲソ。 …んんーーー <a href="https://github.com/ajhc/ajhc-dumpyard/tree/master/emulateTimingDelay">完成でゲソー!</a></p>
<p>このプログラムはTimingとDelayの2つのスレッドが動作して、 Delayスレッドの待ち合わせをTimingスレッドが解除するでゲソ。 実行してみると3秒毎に経過時間がコンソールに印字されるはずでゲソ。</p>
<p>まずC言語側から説明するでゲソ。 main関数はHaskellコードを実行する前にrun_timingDelayDecrement関数を新しいスレッドとして実行するでゲソ。 run_timingDelayDecrement関数は100ミリ秒毎にHaskellのtimingDelayDecrement関数を呼び出すでゲソ。 つまりこのスレッドはタイマー割り込みをエミュレーションしていることになるでゲソ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// main.c</span>
<span class="dt">static</span> <span class="dt">uint32_t</span> TimingDelay = <span class="dv">0</span>;

<span class="dt">uint32_t</span> *
getTimingDelay()
{
        <span class="cf">return</span> &amp;TimingDelay;
}

<span class="dt">void</span> *run_timingDelayDecrement(<span class="dt">void</span> *p)
{
	<span class="cf">for</span> (;;) {
<span class="pp">#define MILLI_SEC(N)  ((N) * 1000)</span>
		usleep(MILLI_SEC(<span class="dv">100</span>));
		timingDelayDecrement();
	}
	<span class="co">/* NOTREACHED */</span>
	<span class="cf">return</span> NULL;
}

<span class="dt">int</span>
main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
	<span class="dt">int</span> err;

        hs_init(&amp;argc,&amp;argv);
        <span class="cf">if</span> (jhc_setjmp(&amp;jhc_uncaught)) {
                jhc_error(<span class="st">&quot;Uncaught Exception&quot;</span>);
        } <span class="cf">else</span> {
		forkOS_createThread(&amp;run_timingDelayDecrement, NULL, &amp;err);
                _amain();
	}
        hs_exit();
        <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>今度はHaskell側でゲソ。 先のrun_timingDelayDecrementスレッドから呼び出されるtimingDelayDecrement関数は単にポインタの先にある uint32_tの値を減算するだけでゲソ。 一方、Haskellのmain関数はmyDelay関数を繰り返し呼び出していて、 さっきのuint32_tに待ち合わせ時間を書き込んだ後、その値が0になるのをループで待ち合わせるでゲソ。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>
<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Foreign.Ptr</span>
<span class="kw">import </span><span class="dt">Foreign.Storable</span>

<span class="co">-- Timing</span>
foreign <span class="kw">import </span>ccall &quot;c_extern.h getTimingDelay&quot; c_gettimingDelay :: <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word32</span>)

<span class="ot">timingDelayDecrement ::</span> <span class="dt">IO</span> ()
timingDelayDecrement <span class="fu">=</span> <span class="kw">do</span>
  p <span class="ot">&lt;-</span> c_gettimingDelay
  i <span class="ot">&lt;-</span> peek p
  when (i <span class="fu">&gt;=</span> <span class="dv">0</span>) <span class="fu">$</span> poke p (i <span class="fu">-</span> <span class="dv">1</span>)

foreign export ccall <span class="st">&quot;timingDelayDecrement&quot;</span><span class="ot"> timingDelayDecrement ::</span> <span class="dt">IO</span> ()

<span class="co">-- Delay</span>
<span class="ot">myDelay ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
myDelay nTime <span class="fu">=</span> <span class="kw">do</span>
  p <span class="ot">&lt;-</span> c_gettimingDelay
  poke p nTime
  <span class="kw">let</span><span class="ot"> while ::</span> <span class="dt">IO</span> ()
      while <span class="fu">=</span> <span class="kw">do</span>
        p' <span class="ot">&lt;-</span> c_gettimingDelay
        i <span class="ot">&lt;-</span> peek p'
        <span class="kw">if</span> (i <span class="fu">&gt;</span> <span class="dv">0</span>) <span class="kw">then</span> while <span class="kw">else</span> return ()
  while

foreign <span class="kw">import </span>ccall &quot;c_extern.h getTime&quot; c_getTime :: <span class="dt">IO</span> <span class="dt">Word64</span></code></pre></div>
<p>これでスレッドの波をすいーいすいーじゃなイカー。</p>
<p>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'metasepi';
    var disqus_identifier = '/posts/2013-06-20-reentrant_jhc.html';
    var disqus_url = 'http://metasepi.org' + '/posts/2013-06-20-reentrant_jhc.html';
    var disqus_title = 'Shape reentrant on Ajhc.';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the 
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    blog comments powered by <span.logo-disqus>Disqus</span>
  </a>
</p>

    </div>

    <footer>
      <p>
        This page is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a>
        <br>
        Metasepi project is supported by
        <a href="https://liferobotics.jp/"><img alt="Life Robotics Inc." style="border-width:0" src="../img/liferobotics-logo_57x25.png" /></a> ×
        <a href="http://www.aics.riken.jp/en/"><img alt="RIKEN AICS" style="border-width:0" src="../img/riken-logo_55x25.png" /></a> ×
        <a href="http://www.metasepi-design.com/"><img alt="METASEPI DESIGN" style="border-width:0" src="../img/metasepi_design_logo_82x25.png" /></a> ×
        <a href="../past-supporters.html">Past Supporters</a>
      </p>
    </footer>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="/js/libs/jquery-1.6.2.min.js"><\/script>')</script>

  <!-- scripts concatenated and minified via ant build script-->
  <script defer src="../js/plugins.js"></script>
  <script defer src="../js/script.js"></script>
  <!-- end scripts-->

  <script>
    window._gaq = [['_setAccount','UA-158383-8'],['_trackPageview'],['_trackPageLoadTime']];
    Modernizr.load({
      load: ('https:' == location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js'
    });
  </script>

  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js">
    <script>
      window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
  <![endif]-->
</body>
