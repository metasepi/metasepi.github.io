<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Jhc compile pipeline: Grin => C (code example) - Metasepi</title>

  <meta name="description" content="metasepi.org">
  <meta name="author" content="Kiwamu Okabe">

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="http://metasepi.org/rss_en.xml" rel="alternate" title="Blog" type="application/rss+xml">

  <!-- CSS concatenated and minified via ant build script-->
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/syntax.css">
  <link rel="stylesheet" href="../css/calendar.css">
  <!-- end CSS-->

  <link rel="stylesheet" href="../css/default.css">

  <script src="../js/libs/modernizr-2.0.6.min.js"></script>
</head>

<body onload="prettyPrint()">
  <div id="fb-root"></div>
  <script>
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) {return;}
      js = d.createElement(s); js.id = id;
      js.src = '//connect.facebook.net/ja_JP/all.js#xfbml=1';
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>

  <header class="topbar">
    <div class="container">
      <div class="brand">
        <a href="../">Metasepi</a>
      </div>

      <div class="nav">
        <li><a href="../">Home</a></li>
        <li><a href="../en/posts.html">Blog</a>(<a href="../posts.html">old</a>)</li>
        <li><a href="../papers.html">Papers</a></li>
        <li><a href="../map.html">Map</a></li>
        <li><a href="../memories.html">Memories</a></li>
        <li><a href="../about.html">About</a></li>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="content clearfix">
      <h1>Jhc compile pipeline: Grin => C (code example)</h1>
<div class="info">Posted on May 16, 2013 / Tags: <a href="../tags/compiler.html">compiler</a>, <a href="../tags/jhc.html">jhc</a>, <a href="../tags/c.html">c</a>, <a href="../tags/grin.html">grin</a></div>
<h2>Table of contents</h2>
<ul>
<li><a href="#ダンプ解析-例による理解">ダンプ解析 (例による理解)</a><ul>
<li><a href="#caf-v-930757141">1. Caf: v-930757141</a></li>
<li><a href="#func-b_main--">2. Func: b_main :: () -&gt; ()</a></li>
<li><a href="#func-fw.fjhc.inst.show.showword-bits32i---n">3. Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</a></li>
<li><a href="#func-fjhc.show.shows-ii---n">4. Func: fJhc.Show.shows :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.show.11_showl-in---n">5. Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</a></li>
<li><a href="#func-fthemain2-ii---n">6. Func: ftheMain$2 :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.basics.-in---n">7. Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</a></li>
<li><a href="#func-fthemain3---n">8. Func: ftheMain$3 :: () -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.basics.zipwith-ii---n">9. Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fw.fr.fjhc.list.387_f-bits32i---n">10. Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</a></li>
<li><a href="#func-fthemain--">11. Func: ftheMain :: () -&gt; ()</a></li>
<li><a href="#grin由来ではないc言語コード">Grin由来ではないC言語コード</a></li>
</ul></li>
</ul>
<hr>
<p>お待ちかねでゲソ! jhcのコンパイルパイプラインを詳細に調査してみようと思うでゲッソ。</p>
<pre><code>$ cat Fib.hs
fibonacci :: [Int]
fibonacci = 1:1:zipWith (+) fibonacci (tail fibonacci)
main :: IO ()
main = print $ take 40 fibonacci
$ make
sh jhc_dump_code.sh Fib.hs &gt; jhc_dump_code.log 2&gt;&amp;1
dot -Tpng hs.out_grin.dot &gt; hs.out_grin.dot.png</code></pre>
<p>この簡単なフィボナッチ数列を出力するだけのプログラムをjhcでコンパイルして、 <a href="https://gitorious.org/metasepi/jhc-arafura/trees/arafura/metasepi-arafura/misc/jhc_dump_fib">そのダンプ</a> を取ったでゲソ。 今回はその中でイカの2つを比較することで、GrinからC言語への変換がどのようになっているのか調査してみようと思うでゲッソ。</p>
<ul>
<li><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/metasepi-arafura/misc/jhc_dump_fib/hs.out_final.grin">hs.out_final.grin</a> - C言語への変換直前のGrin</li>
<li><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/metasepi-arafura/misc/jhc_dump_fib/hs.out_code.c">hs.out_code.c</a> - 最終的なC言語ソース</li>
</ul>
<p>一応、上記のダンプが所望のものかどうかjhc本体のソースコードでチェックしてきるでゲソ。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- jhc/src/Grin/Main.hs</span>
compileToGrin prog <span class="fu">=</span> <span class="kw">do</span>
    stats <span class="ot">&lt;-</span> Stats.new
    putProgressLn <span class="st">&quot;Converting to Grin...&quot;</span>
<span class="co">-- snip --</span>
    x <span class="ot">&lt;-</span> storeAnalyze x
    <span class="ot">=&gt;</span> dumpFinalGrin x
       writeFile (outputName <span class="fu">++</span> <span class="st">&quot;_grin.dot&quot;</span>) (graphGrin grin)
       dumpGrin <span class="st">&quot;final&quot;</span> grin
    compileGrinToC x</code></pre>
<p>うん。ちゃんとC言語に変換する直前のダンプでゲソ。 先のhs.out_final.grinを見てみるとグローバルから辿れる要素はイカのようでゲソ。</p>
<ol style="list-style-type: decimal">
<li>Caf: v-930757141</li>
<li>Func: b_main :: () -&gt; ()</li>
<li>Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</li>
<li>Func: fJhc.Show.shows :: (I,I) -&gt; (N)</li>
<li>Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</li>
<li>Func: ftheMain$2 :: (I,I) -&gt; (N)</li>
<li>Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</li>
<li>Func: ftheMain$3 :: () -&gt; (N)</li>
<li>Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</li>
<li>Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</li>
<li>Func: ftheMain :: () -&gt; ()</li>
</ol>
<p>また、上記の関数は-dgrin-graphが吐いた図によるとイカのような関係にあるらしいでゲソ。</p>
<p><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/misc/jhc_dump_fib/hs.out_grin.dot.png"><img src="https://gitorious.org/metasepi/jhc-arafura/blobs/raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/misc/jhc_dump_fib/hs.out_grin.dot.png" /></a></p>
<p>これらがどのようにC言語に写像されているか、 また逆にC言語ソースコードで上記由来ではない部分が存在するかどうかチェックしてみなイカ？</p>
<h2 id="ダンプ解析-例による理解">ダンプ解析 (例による理解)</h2>
<h3 id="caf-v-930757141">1. Caf: v-930757141</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
<span class="co">-- Cafs</span>
v<span class="fu">-</span><span class="dv">930757141</span> <span class="fu">:=</span> (<span class="dt">FtheMain</span><span class="fu">$</span><span class="dv">3</span>)</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> fptr * fptr_t;
<span class="kw">typedef</span> <span class="kw">struct</span> sptr * sptr_t;
<span class="kw">typedef</span> <span class="kw">struct</span> node {
        fptr_t head;
        sptr_t rest[];
} A_MAYALIAS node_t;

<span class="ot">#define P_WHNF  0x0</span>
<span class="ot">#define P_LAZY  0x1</span>
<span class="ot">#define P_VALUE 0x2</span>
<span class="ot">#define P_FUNC  0x3</span>
<span class="ot">#define TO_SPTR_C(t,x) (typeof (x))((uintptr_t)(x) + (t))</span>
        <span class="co">// attach a ptype to a smart pointer, suitable for use by constant initialializers</span>
<span class="ot">#define TO_FPTR(fn)   TO_SPTR_C(P_FUNC,(fptr_t)fn)</span>
<span class="ot">#define MKLAZY_C(fn)  TO_SPTR_C(P_LAZY,(sptr_t)fn)</span>

<span class="co">/* CAFS */</span>
<span class="co">/* v-930757141 = (FtheMain$3)*/</span>
<span class="dt">static</span> node_t _g930757141 = { .head = TO_FPTR(&amp;E__ftheMain$d3) };
<span class="ot">#define g930757141 (MKLAZY_C(&amp;_g930757141))</span></code></pre>
<p>これを図にまとめると、イカのようになるでゲソ。 CAF(Constant Applicative Form) というのは 「一度実行したら、その結果をメモ化して使いまわせるもの」のことでゲソ。 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> ということはg930757141というのは未評価のサンクで、 このサンクの値を評価して確定させるためにはCode pointerの先にある E__ftheMain$d3()関数を実行する必要があるということが予想できるじゃなイカ。</p>
<div class="figure">
<img src="../draw/2013-02-14-jhc_grin_to_c_1_v-930757141.png" />
</div>
<p>ではこのサンクg930757141はどのように使われるんでゲソ？</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">const</span> <span class="dt">void</span> * <span class="dt">const</span> nh_stuff[] = {
&amp;_g930757141, &amp;_c1, &amp;_c2, &amp;_c3, NULL
};</code></pre>
<p>まずnh_stuff配列から参照されているでゲソ。 これはGCルートのようでゲソ。 グローバルから見えるサンクは当然解放することができないので、 GCルートになるはずでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c">ftheMain
=&gt; eval(gc,g930757141)
   <span class="dt">void</span> *ds = FROM_SPTR(g930757141); <span class="co">// (uintptr_t)(x) &amp; ~0x3)</span>
   sptr_t h = (sptr_t)(GETHEAD(ds)); <span class="co">// ((node_t *)(x))-&gt;head</span>
   eval_fn fn = (eval_fn)FROM_SPTR(h);
   =&gt; wptr_t r =  E__ftheMain$d3(gc,_g930757141); <span class="co">// (*fn)(gc,NODEP(ds));</span>
      =&gt; wptr_t r2 = ftheMain$d3(gc);
         =&gt; <span class="kw">return</span> fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));
      =&gt; update(_g930757141,r2);
         GETHEAD(_g930757141) = (fptr_t)r2;
      gc_add_root(gc,(sptr_t)r2);
      <span class="kw">return</span> r2;
   <span class="kw">return</span> r;</code></pre>
<p>さらg930757141はevel()関数を通して評価され、 最終的に_g930757141のheadメンバーをftheMain$d3()関数の実行結果で上書きしているでゲソ。 結局eval()関数を通したことで、g930757141は未評価サンクから評価済みサンクに変化したんでゲソ。 このeval()関数、場合によってはさらにその子供のサンクを評価するために一度実行に入ると長い時間滞留する可能性があるでゲソ。 jhcのコンパイル結果にeval()を使っている箇所があったら注意して確認する必要があるということになるでゲソ。</p>
<h3 id="func-b_main--">2. Func: b_main :: () -&gt; ()</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
<span class="co">-- Functions</span>
<span class="ot">b_main ::</span> () <span class="ot">-&gt;</span> ()
b_main  <span class="fu">=</span> <span class="kw">do</span>
  ftheMain</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">void</span>
_amain(<span class="dt">void</span>)
{
        <span class="kw">return</span> (<span class="dt">void</span>)b__main(saved_gc);
}

<span class="dt">static</span> <span class="dt">void</span> A_STD
b__main(gc_t gc)
{
        <span class="kw">return</span> ftheMain(gc);
}</code></pre>
<p>うむ。これはなんかそのままでゲソ。 あえて違うところを挙げるとするならsaved_gcを引数で取り回すということでゲソ。 saved_gcはjgcの機能なので、別のGCを選択した場合には当然この出力も変化するはずでゲソ。</p>
<h3 id="func-fw.fjhc.inst.show.showword-bits32i---n">3. Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fW<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord<span class="ot"> ::</span> (bits32,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fW<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w1540496947 ni1826240557 <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span>
      fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w80100072 ni196335308 <span class="fu">=</span> <span class="kw">do</span>
        w40405746 <span class="ot">&lt;-</span> w80100072 <span class="fu">/</span> <span class="dv">10</span>
        w253468956 <span class="ot">&lt;-</span> w80100072 <span class="fu">%</span> <span class="dv">10</span>
        bm124940226 <span class="ot">&lt;-</span> (bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Zx</span> bits32 w253468956
        w132127022 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span> bm124940226
        w26031830 <span class="ot">&lt;-</span> <span class="dv">48</span> <span class="fu">+</span> w132127022
        w260152044 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">B2B</span> bits32 w26031830
        withRoots(ni196335308)
          nd122 <span class="ot">&lt;-</span> dstore (<span class="dt">CJhc.Type.Basic.Char</span> w260152044)
          ni55102202 <span class="ot">&lt;-</span> demote nd122
          <span class="kw">case</span> w40405746 <span class="kw">of</span>
            <span class="dv">0</span> <span class="ot">-&gt;</span> withRoots(ni55102202)
              dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni55102202 ni196335308)
            w0 <span class="ot">-&gt;</span> withRoots(ni55102202)
              nd15 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni55102202 ni196335308)
              ni1829124143 <span class="ot">&lt;-</span> demote nd15
              fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w40405746 ni1829124143
   <span class="kw">in</span>
    fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w1540496947 ni1826240557</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fW$__fJhc_Inst_Show_showWord(gc_t gc,<span class="dt">uint32_t</span> v1540496947,sptr_t v1826240557)
{
        sptr_t v196335308;
        <span class="dt">uint32_t</span> v80100072;
        <span class="co">// let fW@.fR@.fJhc.Inst.Show.showWord w80100072 ni196335308 = do</span>
        <span class="co">// fW@.fR@.fJhc.Inst.Show.showWord w1540496947 ni1826240557</span>
        v80100072 = v1540496947;
        v196335308 = v1826240557;
        fW$__fR$__fJhc_Inst_Show_showWord__2:;
        {   <span class="dt">uint32_t</span> v40405746 = (v80100072 / <span class="dv">10</span>); <span class="co">// w40405746 &lt;- w80100072 / 10</span>
            <span class="dt">uint32_t</span> v253468956 = (v80100072 % <span class="dv">10</span>); <span class="co">// w253468956 &lt;- w80100072 % 10</span>
            uintmax_t v124940226 = ((uintmax_t)v253468956); <span class="co">// bm124940226 &lt;- (bits&lt;max&gt;)ConvOp Zx bits32 w253468956</span>
            <span class="dt">uint32_t</span> v132127022 = ((<span class="dt">uint32_t</span>)v124940226); <span class="co">// w132127022 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm124940226</span>
            <span class="dt">uint32_t</span> v26031830 = (<span class="dv">48</span> + v132127022); <span class="co">// w26031830 &lt;- 48 + w132127022</span>
            <span class="dt">uint32_t</span> v260152044 = v26031830; <span class="co">// w260152044 &lt;- (bits32)ConvOp B2B bits32 w26031830</span>
            {   gc_frame0(gc,<span class="dv">1</span>,v196335308);
                wptr_t v122 = RAW_SET_UF(v260152044); <span class="co">// nd122 &lt;- dstore (CJhc.Type.Basic.Char w260152044)</span>
                sptr_t v55102202 = demote(v122); <span class="co">// ni55102202 &lt;- demote nd122</span>
                <span class="kw">if</span> (<span class="dv">0</span> == v40405746) { <span class="co">// case w40405746 of 0 -&gt;</span>
                    {   gc_frame0(gc,<span class="dv">1</span>,v55102202);
                        wptr_t x3 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)</span>
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x3)-&gt;a1 = v55102202;
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x3)-&gt;a2 = v196335308;
                        <span class="kw">return</span> x3;
                    }
                } <span class="kw">else</span> { <span class="co">// w0 -&gt;</span>
                    {   gc_frame0(gc,<span class="dv">1</span>,v55102202);
                        wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd15 &lt;- dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)</span>
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a1 = v55102202;
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a2 = v196335308;
                        wptr_t v15 = x4;
                        sptr_t v1829124143 = demote(v15); <span class="co">// ni1829124143 &lt;- demote nd15</span>
                        v80100072 = v40405746; <span class="co">// fW@.fR@.fJhc.Inst.Show.showWord w40405746 ni1829124143</span>
                        v196335308 = v1829124143;
                        <span class="kw">goto</span> fW$__fR$__fJhc_Inst_Show_showWord__2;
                    }
                }
            }
        }
}</code></pre>
<p>C言語側にGrinコード断片をコメントで入れてみたでゲソ。 だいたい1対1に対応が取れているじゃなイカ。 ここではGrinとC言語の違いに着目して、そのしくみを詳しく見てみるでゲソ。</p>
<p>まず第一にdstore (CJhc.Type.Basic.Char,x)がRAW_SET_UF(x)になることがあるでゲソ。 このRAW_SET_UF()はイカのような定義で、即値のWHNFに変換してくれるでゲソ。 CJhc.Type.Basic.Charは即値なので、RAW_SET_UF()を使ってスマートポインタに埋め込まれるんじゃなイカ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) &lt;&lt; 2) | P_VALUE))</span></code></pre>
<p>ところがdstore (CJhc.Prim.Prim.: x y) のような場合にはイカのようにs_alloc()でヒープへのスマートポインタを作って、 格納するでゲソ。 これはHaskellの(:)演算子を思いうかべればすぐわかるでゲソ。 (:)演算子は2つの要素をconsし、 そのconsした結果がstruct sCJhc_Prim_Prim_$x3aなんでゲソ。 つまりconsする旅にヒープの領域を消費するということでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {
    sptr_t a1;
    sptr_t a2;
};

wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a);
((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a1 = x;
((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a2 = y;</code></pre>
<p>最後にfW@.fR@.fJhc.Inst.Show.showWord関数の再帰がgotoループになっているでゲソ。 たまたまこの関数の例はすぐにループ化できる再帰だから良かったでゲソ。 しかし、原理的に全ての再帰がループ化されるのカ？少し不安でゲソ…</p>
<h3 id="func-fjhc.show.shows-ii---n">4. Func: fJhc.Show.shows :: (I,I) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>shows<span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>shows ni29375120 ni44000678 <span class="fu">=</span> <span class="kw">do</span>
  withRoots(ni44000678)
    nd100038 <span class="ot">&lt;-</span> eval ni29375120
    (<span class="dt">CJhc.Type.Word.Int</span> w216085094) <span class="ot">&lt;-</span> return nd100038
    h100040 <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="ot">`Gt`</span> w216085094
    <span class="kw">case</span> h100040 <span class="kw">of</span>
      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        w196289068 <span class="ot">&lt;-</span> (bits32)<span class="dt">Neg</span> w216085094
        bm253468954 <span class="ot">&lt;-</span> (bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Sx</span> bits32 w196289068
        w124235152 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span> bm253468954
        ni244126258 <span class="ot">&lt;-</span> istore (<span class="dt">FW</span><span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w124235152 ni44000678)
        withRoots(ni244126258)
          dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">45</span>) ni244126258)
      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        bm220263214 <span class="ot">&lt;-</span> (bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Sx</span> bits32 w216085094
        w110207578 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="fu">&lt;</span>max<span class="fu">&gt;</span> bm220263214
        fW<span class="fu">@.</span>fJhc<span class="fu">.</span>Inst.Show.showWord w110207578 ni44000678</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fJhc_Show_shows(gc_t gc,sptr_t v29375120,sptr_t v44000678)
{
        {   <span class="dt">uint32_t</span> v216085094;
            gc_frame0(gc,<span class="dv">1</span>,v44000678); <span class="co">// withRoots(ni44000678)</span>
            wptr_t v100038 = eval(gc,v29375120); <span class="co">// nd100038 &lt;- eval ni29375120</span>
            v216085094 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100038)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w216085094) &lt;- return nd100038</span>
            <span class="dt">uint16_t</span> v100040 = (((<span class="dt">int32_t</span>)<span class="dv">0</span>) &gt; ((<span class="dt">int32_t</span>)v216085094)); <span class="co">// h100040 &lt;- 0 `Gt` w216085094</span>
            <span class="kw">if</span> (<span class="dv">0</span> == v100040) { <span class="co">// case h100040 of 0 -&gt; do</span>
                uintmax_t v220263214 = ((intmax_t)((<span class="dt">int32_t</span>)v216085094)); <span class="co">// bm220263214 &lt;- (bits&lt;max&gt;)ConvOp Sx bits32 w216085094</span>
                <span class="dt">uint32_t</span> v110207578 = ((<span class="dt">uint32_t</span>)v220263214); <span class="co">// w110207578 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm220263214</span>
                <span class="kw">return</span> fW$__fJhc_Inst_Show_showWord(gc,v110207578,v44000678); <span class="co">// fW@.fJhc.Inst.Show.showWord w110207578 ni44000678</span>
            } <span class="kw">else</span> { <span class="co">// 1 -&gt; do</span>
                <span class="co">/* 1 */</span>
                assert(<span class="dv">1</span> == v100040);
                <span class="dt">uint32_t</span> v196289068 = (-((<span class="dt">int32_t</span>)v216085094)); <span class="co">// w196289068 &lt;- (bits32)Neg w216085094</span>
                uintmax_t v253468954 = ((intmax_t)((<span class="dt">int32_t</span>)v196289068)); <span class="co">// bm253468954 &lt;- (bits&lt;max&gt;)ConvOp Sx bits32 w196289068</span>
                <span class="dt">uint32_t</span> v124235152 = ((<span class="dt">uint32_t</span>)v253468954); <span class="co">// w124235152 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm253468954</span>
                sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord); <span class="co">// ni244126258 &lt;- istore (FW@.fJhc.Inst.Show.showWord w124235152 ni44000678)</span>
                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;head = TO_FPTR(&amp;E__fW$__fJhc_Inst_Show_showWord);
                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a1 = v124235152;
                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a2 = v44000678;
                sptr_t v244126258 = MKLAZY(x5);
                {   gc_frame0(gc,<span class="dv">1</span>,v244126258); <span class="co">// withRoots(ni244126258)</span>
                    wptr_t x6 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: &amp;(CJhc.Type.Basic.Char 45) ni244126258)</span>
                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x6)-&gt;a1 = ((sptr_t)RAW_SET_UF('-'));
                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x6)-&gt;a2 = v244126258;
                    <span class="kw">return</span> x6;
                }
            }
        }
}</code></pre>
<p>これもほぼ1対1に対応しているでゲソが、唯一の例外が istore (FW@.fJhc.Inst.Show.showWord x y) がs_alloc()によるヒープの確保に化けることでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord {
    fptr_t head;
    sptr_t a2;
    <span class="dt">uint32_t</span> a1;
};

sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord);
((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;head = TO_FPTR(&amp;E__fW$__fJhc_Inst_Show_showWord);
((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a1 = x;
((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a2 = y;
sptr_t v244126258 = MKLAZY(x5);</code></pre>
<p>この謎はjhcのjhcライブラリのソース見れば理解できるでゲソ。 showWord関数はイカのように通常のLazyな関数じゃなイカ。 ということはここでは未評価サンクだけ作り後で誰かがforceしてくれるのを待てばいいんでゲソ。 ここで作成する未評価サンクの実体がstruct sFW$__fJhc_Inst_Show_showWordで、 やはりヒープに確保されるでゲソ。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- jhc/lib/jhc/Jhc/Inst/Show.hs</span>
<span class="ot">showWord ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showWord w rest <span class="fu">=</span> w <span class="ot">`seq`</span> <span class="kw">case</span> quotRem w <span class="dv">10</span> <span class="kw">of</span>
    (n',d) <span class="ot">-&gt;</span> n' <span class="ot">`seq`</span> d <span class="ot">`seq`</span> rest' <span class="ot">`seq`</span> <span class="kw">if</span> n' <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> rest' <span class="kw">else</span> showWord n' rest'
        <span class="kw">where</span> rest' <span class="fu">=</span> chr (fromIntegral d <span class="fu">+</span> ord <span class="ch">'0'</span>) <span class="fu">:</span> rest</code></pre>
<h3 id="func-fr.fjhc.show.11_showl-in---n">5. Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>11_<span class="ot">showl ::</span> (<span class="dt">I</span>,<span class="dt">N</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>11_showl ni108431528 nd267777212 <span class="fu">=</span> <span class="kw">do</span>
  ni267777293 <span class="ot">&lt;-</span> demote nd267777212
  withRoots(nd267777212,ni267777293)
    nd100036 <span class="ot">&lt;-</span> eval ni108431528
    (ni126,ni95) <span class="ot">&lt;-</span> <span class="kw">case</span> nd100036 <span class="kw">of</span>
      (<span class="fu">CJhc.Prim.Prim.:</span> ni26 ni67) <span class="ot">-&gt;</span> withRoots(ni26,ni67)
        ni110947984 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>11_showl ni67 nd267777212)
        withRoots(ni110947984)
          ni215884490 <span class="ot">&lt;-</span> istore (FJhc.Show.shows ni26 ni110947984)
          return (<span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">44</span>),ni215884490)
      [] <span class="ot">-&gt;</span> return (<span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">93</span>),ni267777293)
    withRoots(ni95,ni126)
      dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni126 ni95)</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fR$__fJhc_Show_11__showl(gc_t gc,sptr_t v108431528,wptr_t v267777212)
{
        sptr_t v267777293 = demote(v267777212); <span class="co">// ni267777293 &lt;- demote nd267777212</span>
        {   sptr_t v126;
            sptr_t v95;
            <span class="kw">struct</span> tup1 x7;
            gc_frame0(gc,<span class="dv">2</span>,v267777212,v267777293); <span class="co">// withRoots(nd267777212,ni267777293)</span>
            wptr_t v100036 = eval(gc,v108431528); <span class="co">// nd100036 &lt;- eval ni108431528</span>
            <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100036) { <span class="co">// case nd100036 of [] -&gt;</span>
                x7.t0 = ((sptr_t)RAW_SET_UF(']')); <span class="co">// return (&amp;(CJhc.Type.Basic.Char 93),ni267777293)</span>
                x7.t1 = v267777293;
            } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni26 ni67) -&gt;</span>
                sptr_t v26;
                sptr_t v67;
                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni26 ni67) パターンマッチ */</span>
                v26 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100036)-&gt;a1;
                v67 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100036)-&gt;a2;
                {   gc_frame0(gc,<span class="dv">2</span>,v26,v67); <span class="co">// withRoots(ni26,ni67)</span>
                    sptr_t x8 = s_alloc(gc,cFR$__fJhc_Show_11__showl); <span class="co">// ni110947984 &lt;- istore (FR@.fJhc.Show.11_showl ni67 nd267777212)</span>
                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Show_11__showl);
                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;a1 = v67;
                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;a2 = v267777212;
                    sptr_t v110947984 = MKLAZY(x8);
                    {   gc_frame0(gc,<span class="dv">1</span>,v110947984); <span class="co">// withRoots(ni110947984)</span>
                        sptr_t x9 = s_alloc(gc,cFJhc_Show_shows); <span class="co">// ni215884490 &lt;- istore (FJhc.Show.shows ni26 ni110947984)</span>
                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;head = TO_FPTR(&amp;E__fJhc_Show_shows);
                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;a1 = v26;
                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;a2 = v110947984;
                        sptr_t v215884490 = MKLAZY(x9);
                        x7.t0 = ((sptr_t)RAW_SET_UF(',')); <span class="co">// return (&amp;(CJhc.Type.Basic.Char 44),ni215884490)</span>
                        x7.t1 = v215884490;
                    }
                }
            }
            v126 = x7.t0; <span class="co">// (ni126,ni95) &lt;-</span>
            v95 = x7.t1;
            {   gc_frame0(gc,<span class="dv">2</span>,v95,v126); <span class="co">// withRoots(ni95,ni126)</span>
                wptr_t x10 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni126 ni95)</span>
                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x10)-&gt;a1 = v126;
                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x10)-&gt;a2 = v95;
                <span class="kw">return</span> x10;
            }
        }
}</code></pre>
<p>ここまで来るとほぼこれまで仕入れた知識で読めるでゲソ! 新しく出てきた表現をあえて挙げるならタプルでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> tup1 {
    sptr_t t0;
    sptr_t t1;
};</code></pre>
<p>これはもう見たままでゲソ。タプルじゃなイカ。 ところでなんでいきなりタプルを使うことになったんでゲソ？</p>
<p>この関数はjhcライブラリのshowList関数の中にあるshowlローカル関数に由来しているでゲソ。 どうもShowS型の合成を (文字,サンク) というタプルでの表現に変換しているようじゃなイカ。 コンパイルパイプラインの最適化のどこでこの変換が行なわれるのか興味が出てきたでゲソ。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- jhc/lib/jhc/Jhc/Show.hs</span>
<span class="kw">type</span>  <span class="dt">ShowS</span>    <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">class</span>  <span class="dt">Show</span> a  <span class="kw">where</span>
<span class="co">-- snip --</span>
<span class="ot">    showList         ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="co">-- snip --</span>
    showList []       <span class="fu">=</span> showString <span class="st">&quot;[]&quot;</span>
    showList (x<span class="fu">:</span>xs)   <span class="fu">=</span> showChar <span class="ch">'['</span> <span class="fu">.</span> shows x <span class="fu">.</span> showl xs
                        <span class="kw">where</span> showl []     <span class="fu">=</span> showChar <span class="ch">']'</span>
                              showl (x<span class="fu">:</span>xs) <span class="fu">=</span> showChar <span class="ch">','</span> <span class="fu">.</span> shows x <span class="fu">.</span>
                                             showl xs</code></pre>
<h3 id="func-fthemain2-ii---n">6. Func: ftheMain$2 :: (I,I) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
ftheMain<span class="fu">$</span><span class="dv">2</span><span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
ftheMain<span class="fu">$</span><span class="dv">2</span> ni38 ni42 <span class="fu">=</span> <span class="kw">do</span>
  withRoots(ni42)
    nd100032 <span class="ot">&lt;-</span> eval ni38
    withRoots(nd100032)
      nd100092 <span class="ot">&lt;-</span> eval ni42
      (<span class="dt">CJhc.Type.Word.Int</span> w239029634) <span class="ot">&lt;-</span> return nd100032
      (<span class="dt">CJhc.Type.Word.Int</span> w242159974) <span class="ot">&lt;-</span> return nd100092
      w215350916 <span class="ot">&lt;-</span> w239029634 <span class="fu">+</span> w242159974
      dstore (<span class="dt">CJhc.Type.Word.Int</span> w215350916)</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
ftheMain$d2(gc_t gc,sptr_t v38,sptr_t v42)
{
        {   gc_frame0(gc,<span class="dv">1</span>,v42); <span class="co">// withRoots(ni42)</span>
            wptr_t v100032 = eval(gc,v38); <span class="co">// nd100032 &lt;- eval ni38</span>
            {   <span class="dt">uint32_t</span> v239029634;
                <span class="dt">uint32_t</span> v242159974;
                gc_frame0(gc,<span class="dv">1</span>,v100032); <span class="co">// withRoots(nd100032)</span>
                wptr_t v100092 = eval(gc,v42); <span class="co">// nd100092 &lt;- eval ni42</span>
                v239029634 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100032)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w239029634) &lt;- return nd100032</span>
                v242159974 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100092)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w242159974) &lt;- return nd100092</span>
                <span class="dt">uint32_t</span> v215350916 = (v239029634 + v242159974); <span class="co">// w215350916 &lt;- w239029634 + w242159974</span>
                wptr_t x11 = s_alloc(gc,cCJhc_Type_Word_Int); <span class="co">// dstore (CJhc.Type.Word.Int w215350916)</span>
                ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)x11)-&gt;a1 = v215350916;
                <span class="kw">return</span> x11;
            }
        }
}</code></pre>
<p>ここではじめて“+”演算子を使っているでゲソ。 中間に変数をはさんでいるのでわかりにくいでゲソが、全部展開するとイカのような処理のはずでゲソ。 jhcではプリミティブ型が則、C言語のプリミティブ型に落ちるので、こんな芸当ができるんでゲソ!</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> sCJhc_Type_Word_Int {
    <span class="dt">uint32_t</span> a1;
};

((<span class="kw">struct</span> sCJhc_Type_Word_Int*)x11)-&gt;a1 =
  ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100032)-&gt;a1 + ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100092)-&gt;a1;</code></pre>
<h3 id="func-fr.fjhc.basics.-in---n">7. Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fR<span class="fu">@.</span>fJhc<span class="fu">.Basics.++</span><span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">N</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fR<span class="fu">@.</span>fJhc<span class="fu">.Basics.++</span> ni29534742 nd29534740 <span class="fu">=</span> <span class="kw">do</span>
  withRoots(nd29534740)
    nd100000 <span class="ot">&lt;-</span> eval ni29534742
    <span class="kw">case</span> nd100000 <span class="kw">of</span>
      (<span class="fu">CJhc.Prim.Prim.:</span> ni106 ni108) <span class="ot">-&gt;</span> withRoots(ni106,ni108)
        ni69834446 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.Basics.++</span> ni108 nd29534740)
        withRoots(ni69834446)
          dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni106 ni69834446)
      [] <span class="ot">-&gt;</span> return nd29534740</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fR$__fJhc_Basics_$pp(gc_t gc,sptr_t v29534742,wptr_t v29534740)
{
        {   gc_frame0(gc,<span class="dv">1</span>,v29534740); <span class="co">// withRoots(nd29534740)</span>
            wptr_t v100000 = eval(gc,v29534742); <span class="co">// nd100000 &lt;- eval ni29534742</span>
            <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100000) { <span class="co">// case nd100000 of [] -&gt;</span>
                <span class="kw">return</span> v29534740; <span class="co">// return nd29534740</span>
            } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni106 ni108) -&gt;</span>
                sptr_t v106;
                sptr_t v108;
                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni106 ni108) パターンマッチ */</span>
                v106 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100000)-&gt;a1;
                v108 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100000)-&gt;a2;
                {   gc_frame0(gc,<span class="dv">2</span>,v106,v108); <span class="co">// withRoots(ni106,ni108)</span>
                    sptr_t x12 = s_alloc(gc,cFR$__fJhc_Basics_$pp); <span class="co">// ni69834446 &lt;- istore (FR@.fJhc.Basics.++ ni108 nd29534740)</span>
                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_$pp);
                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;a1 = v108;
                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;a2 = v29534740;
                    sptr_t v69834446 = MKLAZY(x12);
                    {   gc_frame0(gc,<span class="dv">1</span>,v69834446); <span class="co">// withRoots(ni69834446)</span>
                        wptr_t x13 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni106 ni69834446)</span>
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x13)-&gt;a1 = v106;
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x13)-&gt;a2 = v69834446;
                        <span class="kw">return</span> x13;
                    }
                }
            }
        }
}</code></pre>
<p>この関数はこれまでの調査結果で理解できるでゲソ。</p>
<h3 id="func-fthemain3---n">8. Func: ftheMain$3 :: () -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
ftheMain<span class="fu">$</span><span class="dv">3</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> (<span class="dt">N</span>)
ftheMain<span class="fu">$</span><span class="dv">3</span>  <span class="fu">=</span> <span class="kw">do</span>
  fR<span class="fu">@.</span>fJhc<span class="fu">.Basics.++</span> <span class="fu">&amp;</span><span class="st">&quot;[]&quot;</span> []</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {
    sptr_t a1;
    sptr_t a2;
};

<span class="ot">#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) &lt;&lt; 2) | P_VALUE))</span>
<span class="ot">#define RAW_SET_16(w)  (wptr_t)(((uintptr_t)(w) &lt;&lt; 16) | P_VALUE)</span>
<span class="ot">#define SET_RAW_TAG(x)    RAW_SET_16(x)</span>

<span class="kw">enum</span> {
    CJhc_Prim_Prim_$BE = <span class="dv">1</span>,
    CJhc_Prim_Prim_$LR = <span class="dv">0</span>,
    CJhc_Prim_Prim_$x3a = <span class="dv">0</span>,
    CJhc_Type_Basic_Char = <span class="dv">0</span>,
    CJhc_Type_Word_Int = <span class="dv">0</span>
};

<span class="co">/* (HcNode CJhc.Prim.Prim.: [Left &amp;(&quot;CJhc.Type.Basic.Char&quot; 93),Left &amp;(&quot;CJhc.Prim.Prim.[]&quot;)],1) */</span>
<span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> sCJhc_Prim_Prim_$x3a _c1 = {.a1 = (sptr_t)RAW_SET_UF(']'), .a2 = (sptr_t)SET_RAW_TAG(CJhc_Prim_Prim_$BE)};
<span class="ot">#define c1 (TO_SPTR_C(P_WHNF, (sptr_t)&amp;_c1))</span>
<span class="co">/* (HcNode CJhc.Prim.Prim.: [Left &amp;(&quot;CJhc.Type.Basic.Char&quot; 91),Right 1],2) */</span>
<span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> sCJhc_Prim_Prim_$x3a _c2 = {.a1 = (sptr_t)RAW_SET_UF('['), .a2 = c1};
<span class="ot">#define c2 (TO_SPTR_C(P_WHNF, (sptr_t)&amp;_c2))</span>

<span class="dt">static</span> wptr_t A_STD A_MALLOC
ftheMain$d3(gc_t gc)
{
        <span class="kw">return</span> fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));
}</code></pre>
<p>いきなりc2というグローバル変数が出てきたじゃなイカ。これはなんでゲソ？</p>
<div class="figure">
<img src="../draw/2013-02-17-jhc_grin_to_c_c2.png" />
</div>
<p>なるほどたしかに fR@.fJhc.Basics.++ &amp;“[]” [] とあったので“[]”という文字列が欲しかったんでゲソね。</p>
<h3 id="func-fr.fjhc.basics.zipwith-ii---n">9. Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fR<span class="fu">@.</span>fJhc<span class="fu">.</span>Basics.zipWith<span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fR<span class="fu">@.</span>fJhc<span class="fu">.</span>Basics.zipWith ni182639120 ni132127014 <span class="fu">=</span> <span class="kw">do</span>
  withRoots(ni132127014)
    nd100028 <span class="ot">&lt;-</span> eval ni182639120
    <span class="kw">case</span> nd100028 <span class="kw">of</span>
      (<span class="fu">CJhc.Prim.Prim.:</span> ni40405740 ni40) <span class="ot">-&gt;</span> withRoots(ni40,ni40405740)
        nd100030 <span class="ot">&lt;-</span> eval ni132127014
        <span class="kw">case</span> nd100030 <span class="kw">of</span>
          (<span class="fu">CJhc.Prim.Prim.:</span> ni194635132 ni116) <span class="ot">-&gt;</span> withRoots(ni116,ni194635132)
            ni248061794 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.</span>Basics.zipWith ni40 ni116)
            withRoots(ni248061794)
              ni229109160 <span class="ot">&lt;-</span> istore (<span class="dt">FtheMain</span><span class="fu">$</span><span class="dv">2</span> ni40405740 ni194635132)
              withRoots(ni229109160)
                dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni229109160 ni248061794)
          [] <span class="ot">-&gt;</span> return []
      [] <span class="ot">-&gt;</span> return []</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fR$__fJhc_Basics_zipWith(gc_t gc,sptr_t v182639120,sptr_t v132127014)
{
        {   gc_frame0(gc,<span class="dv">1</span>,v132127014); <span class="co">// withRoots(ni132127014)</span>
            wptr_t v100028 = eval(gc,v182639120); <span class="co">// nd100028 &lt;- eval ni182639120</span>
            <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100028) { <span class="co">// case nd100028 of [] -&gt;</span>
                <span class="kw">return</span> v100028; <span class="co">// return []</span>
            } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni40405740 ni40) -&gt;</span>
                sptr_t v40;
                sptr_t v40405740;
                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni40405740 ni40) パターンマッチ */</span>
                v40405740 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100028)-&gt;a1;
                v40 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100028)-&gt;a2;
                {   gc_frame0(gc,<span class="dv">2</span>,v40,v40405740); <span class="co">// withRoots(ni40,ni40405740)</span>
                    wptr_t v100030 = eval(gc,v132127014); <span class="co">// nd100030 &lt;- eval ni132127014</span>
                    <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100030) { <span class="co">// case nd100030 of [] -&gt;</span>
                        <span class="kw">return</span> v100030; <span class="co">// return []</span>
                    } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni194635132 ni116) -&gt;</span>
                        sptr_t v116;
                        sptr_t v194635132;
                        <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni194635132 ni116) パターンマッチ */</span>
                        v194635132 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100030)-&gt;a1;
                        v116 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100030)-&gt;a2;
                        {   gc_frame0(gc,<span class="dv">2</span>,v116,v194635132); <span class="co">// withRoots(ni116,ni194635132)</span>
                            sptr_t x14 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); <span class="co">// ni248061794 &lt;- istore (FR@.fJhc.Basics.zipWith ni40 ni116)</span>
                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith);
                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;a1 = v40;
                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;a2 = v116;
                            sptr_t v248061794 = MKLAZY(x14);
                            {   gc_frame0(gc,<span class="dv">1</span>,v248061794); <span class="co">// withRoots(ni248061794)</span>
                                sptr_t x15 = s_alloc(gc,cFtheMain$d2); <span class="co">// ni229109160 &lt;- istore (FtheMain$2 ni40405740 ni194635132)</span>
                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;head = TO_FPTR(&amp;E__ftheMain$d2);
                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;a1 = v40405740;
                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;a2 = v194635132;
                                sptr_t v229109160 = MKLAZY(x15);
                                {   gc_frame0(gc,<span class="dv">1</span>,v229109160); <span class="co">// withRoots(ni229109160)</span>
                                    wptr_t x16 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni229109160 ni248061794)</span>
                                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x16)-&gt;a1 = v229109160;
                                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x16)-&gt;a2 = v248061794;
                                    <span class="kw">return</span> x16;
                                }
                            }
                        }
                    }
                }
            }
        }
}</code></pre>
<p>うむ。これも今の知識で読めるでゲソ。次の人!っでゲッソ。</p>
<h3 id="func-fw.fr.fjhc.list.387_f-bits32i---n">10. Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">List</span><span class="fu">.</span>387_<span class="ot">f ::</span> (bits32,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)
fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">List</span><span class="fu">.</span>387_f w115160438 ni124940224 <span class="fu">=</span> <span class="kw">do</span>
  h100024 <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="ot">`Gte`</span> w115160438
  <span class="kw">case</span> h100024 <span class="kw">of</span>
    <span class="dv">1</span> <span class="ot">-&gt;</span> return []
    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
      nd100026 <span class="ot">&lt;-</span> eval ni124940224
      <span class="kw">case</span> nd100026 <span class="kw">of</span>
        (<span class="fu">CJhc.Prim.Prim.:</span> ni304 ni306) <span class="ot">-&gt;</span> <span class="kw">do</span>
          w194508206 <span class="ot">&lt;-</span> w115160438 <span class="fu">-</span> <span class="dv">1</span>
          withRoots(ni304,ni306)
            ni131889104 <span class="ot">&lt;-</span> istore (<span class="dt">FW</span><span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">List</span><span class="fu">.</span>387_f w194508206 ni306)
            withRoots(ni131889104)
              dstore (<span class="fu">CJhc.Prim.Prim.:</span> ni304 ni131889104)
        [] <span class="ot">-&gt;</span> return []</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> wptr_t A_STD A_MALLOC
fW$__fR$__fJhc_List_387__f(gc_t gc,<span class="dt">uint32_t</span> v115160438,sptr_t v124940224)
{
        <span class="dt">uint16_t</span> v100024 = (((<span class="dt">int32_t</span>)<span class="dv">0</span>) &gt;= ((<span class="dt">int32_t</span>)v115160438)); <span class="co">// h100024 &lt;- 0 `Gte` w115160438</span>
        <span class="kw">if</span> (<span class="dv">0</span> == v100024) { <span class="co">// case h100024 of 0 -&gt; do</span>
            wptr_t v100026 = eval(gc,v124940224); <span class="co">// nd100026 &lt;- eval ni124940224</span>
            <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100026) { <span class="co">// case nd100026 of [] -&gt;</span>
                <span class="kw">return</span> v100026; <span class="co">// return []</span>
            } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni304 ni306) -&gt; do</span>
                sptr_t v304;
                sptr_t v306;
                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni304 ni306) パターンマッチ */</span>
                v304 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100026)-&gt;a1;
                v306 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100026)-&gt;a2;
                <span class="dt">uint32_t</span> v194508206 = (v115160438 - <span class="dv">1</span>); <span class="co">// w194508206 &lt;- w115160438 - 1</span>
                {   gc_frame0(gc,<span class="dv">2</span>,v304,v306); <span class="co">// withRoots(ni304,ni306)</span>
                    sptr_t x17 = s_alloc(gc,cFW$__fR$__fJhc_List_387__f); <span class="co">// ni131889104 &lt;- istore (FW@.fR@.fJhc.List.387_f w194508206 ni306)</span>
                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;head = TO_FPTR(&amp;E__fW$__fR$__fJhc_List_387__f);
                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;a1 = v194508206;
                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;a2 = v306;
                    sptr_t v131889104 = MKLAZY(x17);
                    {   gc_frame0(gc,<span class="dv">1</span>,v131889104); <span class="co">// withRoots(ni131889104)</span>
                        wptr_t x18 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni304 ni131889104)</span>
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x18)-&gt;a1 = v304;
                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x18)-&gt;a2 = v131889104;
                        <span class="kw">return</span> x18;
                    }
                }
            }
        } <span class="kw">else</span> { <span class="co">// 1 -&gt;</span>
            <span class="co">/* 1 */</span>
            assert(<span class="dv">1</span> == v100024);
            <span class="kw">return</span> SET_RAW_TAG(CJhc_Prim_Prim_$BE); <span class="co">// return []</span>
        }
}</code></pre>
<p>これも今までのパターンと同じでゲソ。もはや楽勝でゲソー。</p>
<h3 id="func-fthemain--">11. Func: ftheMain :: () -&gt; ()</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Grin --</span>
<span class="ot">ftheMain ::</span> () <span class="ot">-&gt;</span> ()
ftheMain  <span class="fu">=</span> <span class="kw">do</span>
  nd163 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">?::</span><span class="dt">I</span> <span class="fu">?::</span><span class="dt">I</span>)
  ni856819231 <span class="ot">&lt;-</span> demote nd163
  withRoots(ni856819231)
    nd168 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">?::</span><span class="dt">I</span> <span class="fu">?::</span><span class="dt">I</span>)
    ni220263216 <span class="ot">&lt;-</span> demote nd168
    overwrite ni856819231 (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Word.Int</span> <span class="dv">1</span>) ni220263216)
    withRoots(ni220263216)
      ni144627460 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.</span>Basics.zipWith <span class="fu">?::</span><span class="dt">I</span> <span class="fu">?::</span><span class="dt">I</span>)
      overwrite ni144627460 (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.</span>Basics.zipWith ni856819231 ni220263216)
      overwrite ni220263216 (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Word.Int</span> <span class="dv">1</span>) ni144627460)
      nd100014 <span class="ot">&lt;-</span> fW<span class="fu">@.</span>fR<span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">List</span><span class="fu">.</span>387_f <span class="dv">40</span> ni856819231
      ni78 <span class="ot">&lt;-</span> <span class="kw">case</span> nd100014 <span class="kw">of</span>
        (<span class="fu">CJhc.Prim.Prim.:</span> ni129 ni32) <span class="ot">-&gt;</span> withRoots(ni32,ni129)
          ni194635134 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="fu">@.</span>fJhc<span class="fu">.</span><span class="dt">Show</span><span class="fu">.</span>11_showl ni32 [])
          withRoots(ni194635134)
            ni196335306 <span class="ot">&lt;-</span> istore (FJhc.Show.shows ni129 ni194635134)
            withRoots(ni196335306)
              nd84 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">91</span>) ni196335306)
              demote nd84
        [] <span class="ot">-&gt;</span> return ni<span class="fu">-</span><span class="dv">930757141</span>
      nd100016 <span class="ot">&lt;-</span> eval ni78
      ni81465164 <span class="ot">&lt;-</span> demote nd100016
      nd0 <span class="ot">&lt;-</span> <span class="kw">let</span>
          fJhc<span class="fu">.</span><span class="dt">Monad</span><span class="fu">.</span>72_go ni10 <span class="fu">=</span> <span class="kw">do</span>
            nd100020 <span class="ot">&lt;-</span> eval ni10
            <span class="kw">case</span> nd100020 <span class="kw">of</span>
              (<span class="fu">CJhc.Prim.Prim.:</span> ni12 ni260952206) <span class="ot">-&gt;</span> withRoots(ni260952206)
                nd100022 <span class="ot">&lt;-</span> eval ni12
                (<span class="dt">CJhc.Type.Basic.Char</span> w216085086) <span class="ot">&lt;-</span> return nd100022
                w249143450 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">B2B</span> bits32 w216085086
                (void)jhc_utf8_putchar(int) w249143450
                fJhc<span class="fu">.</span><span class="dt">Monad</span><span class="fu">.</span>72_go ni260952206
              [] <span class="ot">-&gt;</span> return (<span class="dt">CJhc.Prim.Prim</span><span class="fu">.</span>())
       <span class="kw">in</span>
        fJhc<span class="fu">.</span><span class="dt">Monad</span><span class="fu">.</span>72_go ni81465164
      (void)jhc_utf8_putchar(int) <span class="dv">10</span></code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* C言語 */</span>
<span class="dt">static</span> <span class="dt">void</span> A_STD
ftheMain(gc_t gc)
{
        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd163 &lt;- dstore (CJhc.Prim.Prim.: ?::I ?::I)</span>
        wptr_t v163 = x19; <span class="co">// なんで置き換えた？？？</span>
        sptr_t v856819231 = demote(v163); <span class="co">// ni856819231 &lt;- demote nd163</span>
        {   gc_frame0(gc,<span class="dv">1</span>,v856819231); <span class="co">// withRoots(ni856819231)</span>
            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd168 &lt;- dstore (CJhc.Prim.Prim.: ?::I ?::I)</span>
            wptr_t v168 = x20;
            sptr_t v220263216 = demote(v168); <span class="co">// ni220263216 &lt;- demote nd168</span>
            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a1 = c3; <span class="co">// overwrite ni856819231 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni220263216)</span>
            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a2 = v220263216;
            {   sptr_t v10;
                wptr_t v100014;
                sptr_t v78;
                gc_frame0(gc,<span class="dv">1</span>,v220263216); <span class="co">// withRoots(ni220263216)</span>
                sptr_t x21 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); <span class="co">// ni144627460 &lt;- istore (FR@.fJhc.Basics.zipWith ?::I ?::I)</span>
                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x21)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith);
                sptr_t v144627460 = MKLAZY(x21);
                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith); <span class="co">// overwrite ni144627460 (FR@.fJhc.Basics.zipWith ni856819231 ni220263216)</span>
                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;a1 = v856819231;
                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;a2 = v220263216;
                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))-&gt;a1 = c3; <span class="co">// overwrite ni220263216 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni144627460)</span>
                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))-&gt;a2 = v144627460;
                v100014 = fW$__fR$__fJhc_List_387__f(gc,<span class="dv">40</span>,v856819231); <span class="co">// nd100014 &lt;- fW@.fR@.fJhc.List.387_f 40 ni856819231</span>
                <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100014) { <span class="co">// ni78 &lt;- case nd100014 of [] -&gt;</span>
                    v78 = g930757141; <span class="co">// return ni-930757141</span>
                } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni129 ni32) -&gt;</span>
                    sptr_t v129;
                    sptr_t v32;
                    <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni129 ni32) パターンマッチ */</span>
                    v129 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100014)-&gt;a1;
                    v32 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100014)-&gt;a2;
                    {   gc_frame0(gc,<span class="dv">2</span>,v32,v129); <span class="co">// withRoots(ni32,ni129)</span>
                        sptr_t x22 = s_alloc(gc,cFR$__fJhc_Show_11__showl); <span class="co">// ni194635134 &lt;- istore (FR@.fJhc.Show.11_showl ni32 [])</span>
                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Show_11__showl);
                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;a1 = v32;
                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;a2 = SET_RAW_TAG(CJhc_Prim_Prim_$BE);
                        sptr_t v194635134 = MKLAZY(x22);
                        {   gc_frame0(gc,<span class="dv">1</span>,v194635134); <span class="co">// withRoots(ni194635134)</span>
                            sptr_t x23 = s_alloc(gc,cFJhc_Show_shows); <span class="co">// ni196335306 &lt;- istore (FJhc.Show.shows ni129 ni194635134)</span>
                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;head = TO_FPTR(&amp;E__fJhc_Show_shows);
                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;a1 = v129;
                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;a2 = v194635134;
                            sptr_t v196335306 = MKLAZY(x23);
                            {   gc_frame0(gc,<span class="dv">1</span>,v196335306); <span class="co">// withRoots(ni196335306)</span>
                                wptr_t x24 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd84 &lt;- dstore (CJhc.Prim.Prim.: &amp;(CJhc.Type.Basic.Char 91) ni196335306)</span>
                                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x24)-&gt;a1 = ((sptr_t)RAW_SET_UF('['));
                                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x24)-&gt;a2 = v196335306;
                                wptr_t v84 = x24;
                                v78 = demote(v84); <span class="co">// demote nd84</span>
                            }
                        }
                    }
                }
                wptr_t v100016 = eval(gc,v78); <span class="co">// nd100016 &lt;- eval ni78</span>
                sptr_t v81465164 = demote(v100016); <span class="co">// ni81465164 &lt;- demote nd100016</span>
                v10 = v81465164; <span class="co">// in fJhc.Monad.72_go ni81465164</span>
                fJhc_Monad_72__go__25:; <span class="co">// let fJhc.Monad.72_go ni10 = do</span>
                {   wptr_t v100020 = eval(gc,v10); <span class="co">// nd100020 &lt;- eval ni10</span>
                    <span class="kw">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100020) { <span class="co">// case nd100020 of [] -&gt;</span>
                        SET_RAW_TAG(CJhc_Prim_Prim_$LR); <span class="co">// return (CJhc.Prim.Prim.())</span>
                    } <span class="kw">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni12 ni260952206) -&gt;</span>
                        sptr_t v12;
                        sptr_t v260952206;
                        <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni12 ni260952206) パターンマッチ */</span>
                        v12 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100020)-&gt;a1;
                        v260952206 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100020)-&gt;a2;
                        {   <span class="dt">uint32_t</span> v216085086;
                            gc_frame0(gc,<span class="dv">1</span>,v260952206); <span class="co">// withRoots(ni260952206)</span>
                            wptr_t v100022 = eval(gc,v12); <span class="co">// nd100022 &lt;- eval ni12</span>
                            v216085086 = ((<span class="dt">uint32_t</span>)RAW_GET_UF(v100022)); <span class="co">// (CJhc.Type.Basic.Char w216085086) &lt;- return nd100022</span>
                            <span class="dt">uint32_t</span> v249143450 = v216085086; <span class="co">// w249143450 &lt;- (bits32)ConvOp B2B bits32 w216085086</span>
                            saved_gc = gc; <span class="co">// なにこれ？</span>
                            (<span class="dt">void</span>)jhc_utf8_putchar((<span class="dt">int</span>)v249143450); <span class="co">// (void)jhc_utf8_putchar(int) w249143450</span>
                            v10 = v260952206; <span class="co">// fJhc.Monad.72_go ni260952206</span>
                            <span class="kw">goto</span> fJhc_Monad_72__go__25;
                        }
                    }
                }
                saved_gc = gc; <span class="co">// なにこれ？</span>
                <span class="kw">return</span> (<span class="dt">void</span>)jhc_utf8_putchar((<span class="dt">int</span>)<span class="dv">10</span>); <span class="co">// (void)jhc_utf8_putchar(int) 10</span>
            }
        }
}</code></pre>
<p>overwriteという不吉なキーワードはなんでゲソ？ “overwrite ni856819231 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni220263216)”に着目すると、 元のコードは…</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  nd163 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">?::</span><span class="dt">I</span> <span class="fu">?::</span><span class="dt">I</span>)
  ni856819231 &lt;- demote nd163 // 一度目の束縛
  withRoots(ni856819231)
    nd168 <span class="ot">&lt;-</span> dstore (<span class="fu">CJhc.Prim.Prim.:</span> <span class="fu">?::</span><span class="dt">I</span> <span class="fu">?::</span><span class="dt">I</span>)
    ni220263216 <span class="ot">&lt;-</span> demote nd168
    overwrite ni856819231 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.<span class="dt">Int</span> 1) ni220263216) // 二度目の束縛</code></pre>
<p>これがC言語に変換されると…</p>
<pre class="sourceCode c"><code class="sourceCode c">        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// スマートポインタを埋めずallocだけ</span>
        wptr_t v163 = x19;
        sptr_t v856819231 = demote(v163); <span class="co">// 一度目のスマートポインタ代入</span>
        {   gc_frame0(gc,<span class="dv">1</span>,v856819231);
            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// a2に入れるスマートポインタをalloc</span>
            wptr_t v168 = x20;
            sptr_t v220263216 = demote(v168);
            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a1 = c3; <span class="co">// alloc済みスマートポインタに代入</span>
            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a2 = v220263216;</code></pre>
<p>ということはoverwriteキーワードはdstoreなどと異なりヒープ領域を確保せず、 第一引数で指定されたスマートポインタを上書きすると考えられるじゃなイカ。 なんとなく上記の例ではoverwriteを使わず一回のdstoreにしてしまっても問題なさそうでゲソが、 コンストラクタと初期化を分割したり、再帰の中で次々に値を更新して結果を得たい場合などに重宝しそうでゲソ。</p>
<p>もう一つ気になるのは“saved_gc = gc”でゲソ。Grinにはなかった行がC言語にいきなり現われるでゲソ… saved_gcはb__main関数から第一引数として取り回されるので、 同じものだと思っていたでゲソ。ここはよくわからなかったでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> 
_amain(<span class="dt">void</span>)
{
        <span class="kw">return</span> (<span class="dt">void</span>)b__main(saved_gc);
}

<span class="dt">static</span> <span class="dt">void</span> A_STD
b__main(gc_t gc)
{
        <span class="kw">return</span> ftheMain(gc);
}</code></pre>
<h3 id="grin由来ではないc言語コード">Grin由来ではないC言語コード</h3>
<p>さて。Grinの関数がC言語にどう変換されたか見てきたでゲソ。 でも、とりこぼした要素はないか気にならなイカ？ チェックでゲソ!</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> {
    CJhc_Prim_Prim_$BE = <span class="dv">1</span>,
    CJhc_Prim_Prim_$LR = <span class="dv">0</span>,
    CJhc_Prim_Prim_$x3a = <span class="dv">0</span>,
    CJhc_Type_Basic_Char = <span class="dv">0</span>,
    CJhc_Type_Word_Int = <span class="dv">0</span>
};</code></pre>
<p>このenumは有意に使われるのは CJhc_Prim_Prim_$BE だけで、 残りは全く使われていないでゲソ。</p>
<p>CJhc_Prim_Prim_$BE はこれまで見た通り、 リストの終端である [] を表わしていたでゲソ。 どこからでも参照され、中身のない要素はこのようにenumで表わされるようでゲソ。 …しかし16bitしか幅がないので、場合によっては足りなく… ってそんなにNilみたいな要素をばかすか作りっこないでゲッソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {
    sptr_t a1;
    sptr_t a2;
};

<span class="kw">struct</span> sCJhc_Type_Word_Int {
    <span class="dt">uint32_t</span> a1;
};

<span class="kw">struct</span> sFJhc_Show_shows {
    fptr_t head;
    sptr_t a1;
    sptr_t a2;
};

<span class="kw">struct</span> sFR$__fJhc_Basics_$pp {
    fptr_t head;
    sptr_t a1;
    wptr_t a2;
};

<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith {
    fptr_t head;
    sptr_t a1;
    sptr_t a2;
};

<span class="kw">struct</span> sFR$__fJhc_Show_11__showl {
    fptr_t head;
    sptr_t a1;
    wptr_t a2;
};

<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord {
    fptr_t head;
    sptr_t a2;
    <span class="dt">uint32_t</span> a1;
};

<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f {
    fptr_t head;
    sptr_t a2;
    <span class="dt">uint32_t</span> a1;
};

<span class="kw">struct</span> sFtheMain$d2 {
    fptr_t head;
    sptr_t a1;
    sptr_t a2;
};

<span class="kw">struct</span> sFtheMain$d3 {
    fptr_t head;
};</code></pre>
<p>これらのstructはこれまで見てきた通り、ヒープに確保される要素群でゲソ。 特にstructの先頭メンバーがfptr_tになっているstructはサンクでゲソ。 structのメンバーを見ればサンクかどうか分かるのは fptr_tを特別なスマートポインタとして扱っている恩恵でゲッソー。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> 
jhc_hs_init(<span class="dt">void</span>)
{
        find_cache(&amp;cCJhc_Prim_Prim_$x3a,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a)),<span class="dv">2</span>);
        find_cache(&amp;cCJhc_Type_Word_Int,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Type_Word_Int)),<span class="dv">0</span>);
        find_cache(&amp;cFW$__fR$__fJhc_List_387__f,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f)),<span class="dv">2</span>);
        find_cache(&amp;cFR$__fJhc_Basics_zipWith,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith)),<span class="dv">3</span>);
        find_cache(&amp;cFR$__fJhc_Basics_$pp,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Basics_$pp)),<span class="dv">3</span>);
        find_cache(&amp;cFtheMain$d2,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFtheMain$d2)),<span class="dv">3</span>);
        find_cache(&amp;cFR$__fJhc_Show_11__showl,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Show_11__showl)),<span class="dv">3</span>);
        find_cache(&amp;cFJhc_Show_shows,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFJhc_Show_shows)),<span class="dv">3</span>);
        find_cache(&amp;cFW$__fJhc_Inst_Show_showWord,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord)),<span class="dv">2</span>);
}</code></pre>
<p>このjhc_hs_init関数はHaskellのRTSを初期化するお約束のhs_init関数から呼び出されるようでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span>
hs_init(<span class="dt">int</span> *argc, <span class="dt">char</span> **argv[])
{
        <span class="kw">if</span>(!hs_init_count++) {
                jhc_alloc_init();
                jhc_hs_init();</code></pre>
<p>find_cache関数とは何者なのでゲソ？</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> s_cache *
find_cache(<span class="kw">struct</span> s_cache **rsc, <span class="kw">struct</span> s_arena *arena,
           <span class="dt">unsigned</span> <span class="dt">short</span> size, <span class="dt">unsigned</span> <span class="dt">short</span> num_ptrs)
{
        <span class="kw">if</span>(__predict_true(rsc &amp;&amp; *rsc))
                <span class="kw">return</span> *rsc;
        <span class="kw">struct</span> s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);
        <span class="kw">for</span>(;sc;sc = SLIST_NEXT(sc,next)) {
                <span class="kw">if</span>(sc-&gt;size == size &amp;&amp; sc-&gt;num_ptrs == num_ptrs)
                        <span class="kw">goto</span> found;
        }
        sc = new_cache(arena,size,num_ptrs);
found:
        <span class="kw">if</span>(rsc)
                *rsc = sc;
        <span class="kw">return</span> sc;
}

<span class="kw">struct</span> s_cache *
new_cache(<span class="kw">struct</span> s_arena *arena, <span class="dt">unsigned</span> <span class="dt">short</span> size, <span class="dt">unsigned</span> <span class="dt">short</span> num_ptrs)
{
        <span class="kw">struct</span> s_cache *sc = malloc(<span class="kw">sizeof</span>(*sc));
        memset(sc,<span class="dv">0</span>,<span class="kw">sizeof</span>(*sc));
        sc-&gt;arena = arena;
        sc-&gt;size = size;
        sc-&gt;num_ptrs = num_ptrs;
        sc-&gt;flags = <span class="dv">0</span>;
        size_t excess = BLOCK_SIZE - <span class="kw">sizeof</span>(<span class="kw">struct</span> s_block);
        sc-&gt;num_entries = (<span class="dv">8</span>*excess) / (<span class="dv">8</span>*<span class="kw">sizeof</span>(uintptr_t)*size + <span class="dv">1</span>) - <span class="dv">1</span>;
        sc-&gt;color = (<span class="kw">sizeof</span>(<span class="kw">struct</span> s_block) + BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries) +
                        <span class="kw">sizeof</span>(uintptr_t) - <span class="dv">1</span>) / <span class="kw">sizeof</span>(uintptr_t);
        SLIST_INIT(&amp;sc-&gt;blocks);
        SLIST_INIT(&amp;sc-&gt;full_blocks);
        SLIST_INSERT_HEAD(&amp;arena-&gt;caches,sc,next);
        <span class="kw">return</span> sc;
}</code></pre>
<p>struct s_arenaのcachesメンバーには、 サイズとポインタの数で種類分けされたcacheと呼ばれるエントリが列になっているでゲソ。 find_cache関数の第三引数はサイズ、第四引数はポインタの数で、 呼び元が欲しいcacheが既にcachesメンバーに確保されているのかチェックするのがfind_cache関数のでゲソ。 もし対応するエントリがcachesに入ってなかった場合、 find_cache関数はnew_cache関数を呼び出して新しいエントリを確保するんじゃなイカ。 …でもこのcachesメンバーはコンパイル時に静的に確保してしまうこともできそうなもんでゲソ。 ここらへんは改善できそうでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fJhc_Show_shows(gc_t gc,<span class="kw">struct</span> sFJhc_Show_shows* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fJhc_Show_shows(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fR$__fJhc_Basics_$pp(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Basics_$pp* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fR$__fJhc_Basics_$pp(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fR$__fJhc_Basics_zipWith(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fR$__fJhc_Basics_zipWith(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fR$__fJhc_Show_11__showl(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Show_11__showl* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fR$__fJhc_Show_11__showl(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fW$__fJhc_Inst_Show_showWord(gc_t gc,<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fW$__fJhc_Inst_Show_showWord(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__fW$__fR$__fJhc_List_387__f(gc_t gc,<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = fW$__fR$__fJhc_List_387__f(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__ftheMain$d2(gc_t gc,<span class="kw">struct</span> sFtheMain$d2* arg)
{
        {   wptr_t r;
            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));
            r = ftheMain$d2(gc,arg-&gt;a1,arg-&gt;a2);
            update(arg,r);
            <span class="kw">return</span> r;
        }
}

<span class="dt">static</span> wptr_t A_STD A_FALIGNED
E__ftheMain$d3(gc_t gc,<span class="kw">struct</span> sFtheMain$d3* arg)
{
        wptr_t r;
        r = ftheMain$d3(gc);
        update(arg,r);
        gc_add_root(gc,(sptr_t)r);
        <span class="kw">return</span> r;
}</code></pre>
<p>この“E__f“で始まる関数群はほぼ同じことをしているでゲソ。</p>
<ol style="list-style-type: decimal">
<li>gc_frame0(gc,1,MKLAZY(arg));</li>
<li>関数名から“E__f“プレフィックスを除いた関数を呼び出す</li>
<li>update(arg,r);</li>
<li>return r;</li>
</ol>
<p>まず最初のgc_frame0はイカのようなマクロで、 引数argはポインタで、lazy locationフラグを立ててGCルートに追加するでゲソ。</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define TO_SPTR(t,x)   (typeof (x))((uintptr_t)(x) | (t))</span>
<span class="ot">#define MKLAZY(fn)    TO_SPTR(P_LAZY,(sptr_t)fn)</span>
<span class="ot">#define gc_frame0(gc,n,...) void *ptrs[n] = { __VA_ARGS__ }; \</span>
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) gc[i] = (sptr_t)ptrs[i]; \
        gc_t sgc = gc;  gc_t gc = sgc + n;</code></pre>
<p>update関数は“E__f“プレフィックスを除いた関数の返値でargのhead、 つまりfptr_tを上書きするでゲソ。 これは未評価サンクの評価を行なっているんじゃなイカ？</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> node {
        fptr_t head;
        sptr_t rest[];
} A_MAYALIAS node_t;
<span class="ot">#define NODEP(x)     ((node_t *)(x))</span>
<span class="ot">#define GETHEAD(x)   (NODEP(x)-&gt;head)</span>
<span class="kw">inline</span> <span class="dt">static</span> <span class="dt">void</span> update(<span class="dt">void</span> *t, wptr_t n) { GETHEAD(t) = (fptr_t)n; }</code></pre>
<p>もう一度、“1. Caf: v-930757141”を振り替えってみるでゲソ。 詳細に図を描いてみたら未評価サンクが評価される動作がはっきり解ったじゃなイカ!</p>
<div class="figure">
<img src="../draw/2013-02-14-jhc_grin_to_c_E__f.png" />
</div>
<p>うん。なんとなくGrin=&gt;Cがどんな変換なのかイメージがつかめたでゲソ。 次は例による理解ではなく、jhcのソースコードそのものを理解することもできるんじゃなイカ？</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://www.paraiso-lang.org/ikmsm/books/c82.html">簡約!? λカ娘(算) - 参照透明な海を守る会</a> を参照<a href="#fnref1">↩</a></p></li>
</ol>
</div>
<p>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'metasepi';
    var disqus_identifier = '/posts/2013-05-16-jhc_grin_to_c.html';
    var disqus_url = 'http://metasepi.org' + '/posts/2013-05-16-jhc_grin_to_c.html';
    var disqus_title = 'Jhc compile pipeline: Grin => C (code example)';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the 
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    blog comments powered by <span.logo-disqus>Disqus</span>
  </a>
</p>

    </div>

    <footer>
      <p>
        This page is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a>
        <br>
        Metasepi project is supported by <a href="http://www.itpl.co.jp/en/"><img alt="IT Planning, Inc." style="border-width:0" src="../img/it_planning_108x20.png" /></a> ×
	<a href="http://www.centillion.co.jp/en/"><img alt="Centillion Japan Co.,Ltd." style="border-width:0" src="../img/centillion_78x25.png" /></a> ×
        <a href="http://www.metasepi-design.com/"><img alt="METASEPI DESIGN" style="border-width:0" src="../img/metasepi_design_logo_82x25.png" /></a> ×
        <a href="../past-supporters.html">Past Supporters</a>
      </p>
    </footer>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="/js/libs/jquery-1.6.2.min.js"><\/script>')</script>

  <!-- scripts concatenated and minified via ant build script-->
  <script defer src="../js/plugins.js"></script>
  <script defer src="../js/script.js"></script>
  <!-- end scripts-->

  <script>
    window._gaq = [['_setAccount','UA-158383-8'],['_trackPageview'],['_trackPageLoadTime']];
    Modernizr.load({
      load: ('https:' == location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js'
    });
  </script>

  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js">
    <script>
      window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
  <![endif]-->

<script type="text/javascript">
<!--
(function() {
var login = '',
    fpf = true,
    fpn = '__ulfpc';

// DO NOT ALTER BELOW THIS LINE
var id = 6008444, h = 'a5fe';
var rand = rand || Math.floor(Math.random() * 9000000) + 1000000;
if('http:'==document.location.protocol){var params={id:id,lt:3,h:h,url:document.URL,ref:document.referrer,lg:login,rand:rand,bw:(window.innerWidth?window.innerWidth:(document.documentElement && document.documentElement.clientWidth!=0?document.documentElement.clientWidth:(document.body?document.body.clientWidth:0 ))),bh:(window.innerHeight?window.innerHeight:(document.documentElement && document.documentElement.clientHeight!=0?document.documentElement.clientHeight:(document.body?document.body.clientHeight:0 ))),dpr:(window.devicePixelRatio!=undefined?window.devicePixelRatio:0),sw:screen.width,sh:screen.height,dpr:(window.devicePixelRatio!=undefined?window.devicePixelRatio:0),sb:document.title,guid:'ON'};if(fpf){params.fp=getuid(fpn);}params.eflg=1;var a=document.createElement('a');var lg=document.createElement('img');lg.setAttribute('id','_ullogimgltr');lg.setAttribute('width',1);lg.setAttribute('height',1);lg.setAttribute('alt','');var src='http://le.nakanohito.jp/le/1/?';for(var key in params ) src=src.concat(key+'='+encodeURIComponent(params[key] )+'&');lg.src=src.slice(0,-1);a.setAttribute('href','http://smartphone.userlocal.jp/');a.setAttribute('target','_blank');a.appendChild(lg);var s=document.getElementsByTagName('body')[0];s.appendChild(a);}
function getuid(key){var arr=[],date=new Date(),exp=new Date();exp.setFullYear(exp.getFullYear()+7);if(document.cookie){arr=document.cookie.split(";");for(var i=0; i<arr.length; i++ ){var str=arr[i].replace(/^\s+|\s+