<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Jhc compile pipeline: Grin => C (code example) - Metasepi</title>

  <meta name="description" content="metasepi.org">
  <meta name="author" content="Kiwamu Okabe">

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="http://metasepi.org/rss_en.xml" rel="alternate" title="Blog" type="application/rss+xml">

  <!-- CSS concatenated and minified via ant build script-->
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/syntax.css">
  <link rel="stylesheet" href="../css/calendar.css">
  <!-- end CSS-->

  <link rel="stylesheet" href="../css/default.css">

  <script src="../js/libs/modernizr-2.0.6.min.js"></script>
</head>

<body onload="prettyPrint()">
  <div id="fb-root"></div>
  <script>
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) {return;}
      js = d.createElement(s); js.id = id;
      js.src = '//connect.facebook.net/ja_JP/all.js#xfbml=1';
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>

  <header class="topbar">
    <div class="container">
      <div class="brand">
        <a href="../">Metasepi</a>
      </div>

      <div class="nav">
        <li><a href="../">Home</a></li>
        <li><a href="../en/posts.html">Blog</a></li>
        <li><a href="../papers.html">Papers</a></li>
        <li><a href="../map.html">Map</a></li>
        <li><a href="../memories.html">Memories</a></li>
        <li><a href="../about.html">About</a></li>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="content clearfix">
      <h1>Jhc compile pipeline: Grin => C (code example)</h1>
<div class="info">Posted on May 16, 2013 / Tags: <a href="../tags/compiler.html">compiler</a>, <a href="../tags/jhc.html">jhc</a>, <a href="../tags/c.html">c</a>, <a href="../tags/grin.html">grin</a></div>
<h2>Table of contents</h2>
<ul>
<li><a href="#ダンプ解析-例による理解">ダンプ解析 (例による理解)</a><ul>
<li><a href="#caf-v-930757141">1. Caf: v-930757141</a></li>
<li><a href="#func-b_main--">2. Func: b_main :: () -&gt; ()</a></li>
<li><a href="#func-fw.fjhc.inst.show.showword-bits32i---n">3. Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</a></li>
<li><a href="#func-fjhc.show.shows-ii---n">4. Func: fJhc.Show.shows :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.show.11_showl-in---n">5. Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</a></li>
<li><a href="#func-fthemain2-ii---n">6. Func: ftheMain$2 :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.basics.-in---n">7. Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</a></li>
<li><a href="#func-fthemain3---n">8. Func: ftheMain$3 :: () -&gt; (N)</a></li>
<li><a href="#func-fr.fjhc.basics.zipwith-ii---n">9. Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</a></li>
<li><a href="#func-fw.fr.fjhc.list.387_f-bits32i---n">10. Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</a></li>
<li><a href="#func-fthemain--">11. Func: ftheMain :: () -&gt; ()</a></li>
<li><a href="#grin由来ではないc言語コード">Grin由来ではないC言語コード</a></li>
</ul></li>
</ul>
<hr>
<p>お待ちかねでゲソ! jhcのコンパイルパイプラインを詳細に調査してみようと思うでゲッソ。</p>
<pre><code>$ cat Fib.hs
fibonacci :: [Int]
fibonacci = 1:1:zipWith (+) fibonacci (tail fibonacci)
main :: IO ()
main = print $ take 40 fibonacci
$ make
sh jhc_dump_code.sh Fib.hs &gt; jhc_dump_code.log 2&gt;&amp;1
dot -Tpng hs.out_grin.dot &gt; hs.out_grin.dot.png</code></pre>
<p>この簡単なフィボナッチ数列を出力するだけのプログラムをjhcでコンパイルして、 <a href="https://gitorious.org/metasepi/jhc-arafura/trees/arafura/metasepi-arafura/misc/jhc_dump_fib">そのダンプ</a> を取ったでゲソ。 今回はその中でイカの2つを比較することで、GrinからC言語への変換がどのようになっているのか調査してみようと思うでゲッソ。</p>
<ul>
<li><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/metasepi-arafura/misc/jhc_dump_fib/hs.out_final.grin">hs.out_final.grin</a> - C言語への変換直前のGrin</li>
<li><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/metasepi-arafura/misc/jhc_dump_fib/hs.out_code.c">hs.out_code.c</a> - 最終的なC言語ソース</li>
</ul>
<p>一応、上記のダンプが所望のものかどうかjhc本体のソースコードでチェックしてきるでゲソ。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- jhc/src/Grin/Main.hs</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>compileToGrin prog <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    stats <span class="ot">&lt;-</span> Stats.new</span>
<span id="cb2-4"><a href="#cb2-4"></a>    putProgressLn <span class="st">&quot;Converting to Grin...&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">-- snip --</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    x <span class="ot">&lt;-</span> storeAnalyze x</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="ot">=&gt;</span> dumpFinalGrin x</span>
<span id="cb2-8"><a href="#cb2-8"></a>       <span class="fu">writeFile</span> (outputName <span class="op">++</span> <span class="st">&quot;_grin.dot&quot;</span>) (graphGrin grin)</span>
<span id="cb2-9"><a href="#cb2-9"></a>       dumpGrin <span class="st">&quot;final&quot;</span> grin</span>
<span id="cb2-10"><a href="#cb2-10"></a>    compileGrinToC x</span></code></pre></div>
<p>うん。ちゃんとC言語に変換する直前のダンプでゲソ。 先のhs.out_final.grinを見てみるとグローバルから辿れる要素はイカのようでゲソ。</p>
<ol type="1">
<li>Caf: v-930757141</li>
<li>Func: b_main :: () -&gt; ()</li>
<li>Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</li>
<li>Func: fJhc.Show.shows :: (I,I) -&gt; (N)</li>
<li>Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</li>
<li>Func: ftheMain$2 :: (I,I) -&gt; (N)</li>
<li>Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</li>
<li>Func: ftheMain$3 :: () -&gt; (N)</li>
<li>Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</li>
<li>Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</li>
<li>Func: ftheMain :: () -&gt; ()</li>
</ol>
<p>また、上記の関数は-dgrin-graphが吐いた図によるとイカのような関係にあるらしいでゲソ。</p>
<p><a href="https://gitorious.org/metasepi/jhc-arafura/blobs/raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/misc/jhc_dump_fib/hs.out_grin.dot.png"><img src="https://gitorious.org/metasepi/jhc-arafura/blobs/raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/misc/jhc_dump_fib/hs.out_grin.dot.png" /></a></p>
<p>これらがどのようにC言語に写像されているか、 また逆にC言語ソースコードで上記由来ではない部分が存在するかどうかチェックしてみなイカ？</p>
<h2 id="ダンプ解析-例による理解">ダンプ解析 (例による理解)</h2>
<h3 id="caf-v-930757141">1. Caf: v-930757141</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- Grin --</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">-- Cafs</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>v<span class="op">-</span><span class="dv">930757141</span> <span class="op">:=</span> (<span class="dt">FtheMain</span><span class="op">$</span><span class="dv">3</span>)</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">typedef</span> <span class="kw">struct</span> fptr * fptr_t;</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">typedef</span> <span class="kw">struct</span> sptr * sptr_t;</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">typedef</span> <span class="kw">struct</span> node {</span>
<span id="cb4-5"><a href="#cb4-5"></a>        fptr_t head;</span>
<span id="cb4-6"><a href="#cb4-6"></a>        sptr_t rest[];</span>
<span id="cb4-7"><a href="#cb4-7"></a>} A_MAYALIAS node_t;</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="pp">#define P_WHNF  0x0</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="pp">#define P_LAZY  0x1</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="pp">#define P_VALUE 0x2</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="pp">#define P_FUNC  0x3</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="pp">#define TO_SPTR_C(t,x) (typeof (x))((uintptr_t)(x) + (t))</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="co">// attach a ptype to a smart pointer, suitable for use by constant initialializers</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="pp">#define TO_FPTR(fn)   TO_SPTR_C(P_FUNC,(fptr_t)fn)</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="pp">#define MKLAZY_C(fn)  TO_SPTR_C(P_LAZY,(sptr_t)fn)</span></span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">/* CAFS */</span></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co">/* v-930757141 = (FtheMain$3)*/</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="dt">static</span> node_t _g930757141 = { .head = TO_FPTR(&amp;E__ftheMain$d3) };</span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="pp">#define g930757141 (MKLAZY_C(&amp;_g930757141))</span></span></code></pre></div>
<p>これを図にまとめると、イカのようになるでゲソ。 CAF(Constant Applicative Form) というのは 「一度実行したら、その結果をメモ化して使いまわせるもの」のことでゲソ。 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> ということはg930757141というのは未評価のサンクで、 このサンクの値を評価して確定させるためにはCode pointerの先にある E__ftheMain$d3()関数を実行する必要があるということが予想できるじゃなイカ。</p>
<p><img src="../draw/2013-02-14-jhc_grin_to_c_1_v-930757141.png" /></p>
<p>ではこのサンクg930757141はどのように使われるんでゲソ？</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">const</span> <span class="dt">void</span> * <span class="dt">const</span> nh_stuff[] = {</span>
<span id="cb5-2"><a href="#cb5-2"></a>&amp;_g930757141, &amp;_c1, &amp;_c2, &amp;_c3, NULL</span>
<span id="cb5-3"><a href="#cb5-3"></a>};</span></code></pre></div>
<p>まずnh_stuff配列から参照されているでゲソ。 これはGCルートのようでゲソ。 グローバルから見えるサンクは当然解放することができないので、 GCルートになるはずでゲソ。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a>ftheMain</span>
<span id="cb6-2"><a href="#cb6-2"></a>=&gt; eval(gc,g930757141)</span>
<span id="cb6-3"><a href="#cb6-3"></a>   <span class="dt">void</span> *ds = FROM_SPTR(g930757141); <span class="co">// (uintptr_t)(x) &amp; ~0x3)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>   sptr_t h = (sptr_t)(GETHEAD(ds)); <span class="co">// ((node_t *)(x))-&gt;head</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>   eval_fn fn = (eval_fn)FROM_SPTR(h);</span>
<span id="cb6-6"><a href="#cb6-6"></a>   =&gt; wptr_t r =  E__ftheMain$d3(gc,_g930757141); <span class="co">// (*fn)(gc,NODEP(ds));</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>      =&gt; wptr_t r2 = ftheMain$d3(gc);</span>
<span id="cb6-8"><a href="#cb6-8"></a>         =&gt; <span class="cf">return</span> fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));</span>
<span id="cb6-9"><a href="#cb6-9"></a>      =&gt; update(_g930757141,r2);</span>
<span id="cb6-10"><a href="#cb6-10"></a>         GETHEAD(_g930757141) = (fptr_t)r2;</span>
<span id="cb6-11"><a href="#cb6-11"></a>      gc_add_root(gc,(sptr_t)r2);</span>
<span id="cb6-12"><a href="#cb6-12"></a>      <span class="cf">return</span> r2;</span>
<span id="cb6-13"><a href="#cb6-13"></a>   <span class="cf">return</span> r;</span></code></pre></div>
<p>さらg930757141はevel()関数を通して評価され、 最終的に_g930757141のheadメンバーをftheMain$d3()関数の実行結果で上書きしているでゲソ。 結局eval()関数を通したことで、g930757141は未評価サンクから評価済みサンクに変化したんでゲソ。 このeval()関数、場合によってはさらにその子供のサンクを評価するために一度実行に入ると長い時間滞留する可能性があるでゲソ。 jhcのコンパイル結果にeval()を使っている箇所があったら注意して確認する必要があるということになるでゲソ。</p>
<h3 id="func-b_main--">2. Func: b_main :: () -&gt; ()</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- Grin --</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">-- Functions</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">b_main ::</span> () <span class="ot">-&gt;</span> ()</span>
<span id="cb7-4"><a href="#cb7-4"></a>b_main  <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  ftheMain</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="dt">void</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>_amain(<span class="dt">void</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a>{</span>
<span id="cb8-5"><a href="#cb8-5"></a>        <span class="cf">return</span> (<span class="dt">void</span>)b__main(saved_gc);</span>
<span id="cb8-6"><a href="#cb8-6"></a>}</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="dt">static</span> <span class="dt">void</span> A_STD</span>
<span id="cb8-9"><a href="#cb8-9"></a>b__main(gc_t gc)</span>
<span id="cb8-10"><a href="#cb8-10"></a>{</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="cf">return</span> ftheMain(gc);</span>
<span id="cb8-12"><a href="#cb8-12"></a>}</span></code></pre></div>
<p>うむ。これはなんかそのままでゲソ。 あえて違うところを挙げるとするならsaved_gcを引数で取り回すということでゲソ。 saved_gcはjgcの機能なので、別のGCを選択した場合には当然この出力も変化するはずでゲソ。</p>
<h3 id="func-fw.fjhc.inst.show.showword-bits32i---n">3. Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -&gt; (N)</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- Grin --</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>fW<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord<span class="ot"> ::</span> (bits32,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb9-3"><a href="#cb9-3"></a>fW<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w1540496947 ni1826240557 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="kw">let</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>      fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w80100072 ni196335308 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>        w40405746 <span class="ot">&lt;-</span> w80100072 <span class="op">/</span> <span class="dv">10</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>        w253468956 <span class="ot">&lt;-</span> w80100072 <span class="op">%</span> <span class="dv">10</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>        bm124940226 <span class="ot">&lt;-</span> (bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Zx</span> bits32 w253468956</span>
<span id="cb9-9"><a href="#cb9-9"></a>        w132127022 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span> bm124940226</span>
<span id="cb9-10"><a href="#cb9-10"></a>        w26031830 <span class="ot">&lt;-</span> <span class="dv">48</span> <span class="op">+</span> w132127022</span>
<span id="cb9-11"><a href="#cb9-11"></a>        w260152044 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">B2B</span> bits32 w26031830</span>
<span id="cb9-12"><a href="#cb9-12"></a>        withRoots(ni196335308)</span>
<span id="cb9-13"><a href="#cb9-13"></a>          nd122 <span class="ot">&lt;-</span> dstore (<span class="dt">CJhc.Type.Basic.Char</span> w260152044)</span>
<span id="cb9-14"><a href="#cb9-14"></a>          ni55102202 <span class="ot">&lt;-</span> demote nd122</span>
<span id="cb9-15"><a href="#cb9-15"></a>          <span class="kw">case</span> w40405746 <span class="kw">of</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>            <span class="dv">0</span> <span class="ot">-&gt;</span> withRoots(ni55102202)</span>
<span id="cb9-17"><a href="#cb9-17"></a>              dstore (<span class="op">CJhc.Prim.Prim.:</span> ni55102202 ni196335308)</span>
<span id="cb9-18"><a href="#cb9-18"></a>            w0 <span class="ot">-&gt;</span> withRoots(ni55102202)</span>
<span id="cb9-19"><a href="#cb9-19"></a>              nd15 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> ni55102202 ni196335308)</span>
<span id="cb9-20"><a href="#cb9-20"></a>              ni1829124143 <span class="ot">&lt;-</span> demote nd15</span>
<span id="cb9-21"><a href="#cb9-21"></a>              fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w40405746 ni1829124143</span>
<span id="cb9-22"><a href="#cb9-22"></a>   <span class="kw">in</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>    fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w1540496947 ni1826240557</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb10-3"><a href="#cb10-3"></a>fW$__fJhc_Inst_Show_showWord(gc_t gc,<span class="dt">uint32_t</span> v1540496947,sptr_t v1826240557)</span>
<span id="cb10-4"><a href="#cb10-4"></a>{</span>
<span id="cb10-5"><a href="#cb10-5"></a>        sptr_t v196335308;</span>
<span id="cb10-6"><a href="#cb10-6"></a>        <span class="dt">uint32_t</span> v80100072;</span>
<span id="cb10-7"><a href="#cb10-7"></a>        <span class="co">// let fW@.fR@.fJhc.Inst.Show.showWord w80100072 ni196335308 = do</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>        <span class="co">// fW@.fR@.fJhc.Inst.Show.showWord w1540496947 ni1826240557</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>        v80100072 = v1540496947;</span>
<span id="cb10-10"><a href="#cb10-10"></a>        v196335308 = v1826240557;</span>
<span id="cb10-11"><a href="#cb10-11"></a>        fW$__fR$__fJhc_Inst_Show_showWord__2:;</span>
<span id="cb10-12"><a href="#cb10-12"></a>        {   <span class="dt">uint32_t</span> v40405746 = (v80100072 / <span class="dv">10</span>); <span class="co">// w40405746 &lt;- w80100072 / 10</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>            <span class="dt">uint32_t</span> v253468956 = (v80100072 % <span class="dv">10</span>); <span class="co">// w253468956 &lt;- w80100072 % 10</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>            <span class="dt">uintmax_t</span> v124940226 = ((<span class="dt">uintmax_t</span>)v253468956); <span class="co">// bm124940226 &lt;- (bits&lt;max&gt;)ConvOp Zx bits32 w253468956</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>            <span class="dt">uint32_t</span> v132127022 = ((<span class="dt">uint32_t</span>)v124940226); <span class="co">// w132127022 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm124940226</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>            <span class="dt">uint32_t</span> v26031830 = (<span class="dv">48</span> + v132127022); <span class="co">// w26031830 &lt;- 48 + w132127022</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>            <span class="dt">uint32_t</span> v260152044 = v26031830; <span class="co">// w260152044 &lt;- (bits32)ConvOp B2B bits32 w26031830</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>            {   gc_frame0(gc,<span class="dv">1</span>,v196335308);</span>
<span id="cb10-19"><a href="#cb10-19"></a>                wptr_t v122 = RAW_SET_UF(v260152044); <span class="co">// nd122 &lt;- dstore (CJhc.Type.Basic.Char w260152044)</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>                sptr_t v55102202 = demote(v122); <span class="co">// ni55102202 &lt;- demote nd122</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>                <span class="cf">if</span> (<span class="dv">0</span> == v40405746) { <span class="co">// case w40405746 of 0 -&gt;</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>                    {   gc_frame0(gc,<span class="dv">1</span>,v55102202);</span>
<span id="cb10-23"><a href="#cb10-23"></a>                        wptr_t x3 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x3)-&gt;a1 = v55102202;</span>
<span id="cb10-25"><a href="#cb10-25"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x3)-&gt;a2 = v196335308;</span>
<span id="cb10-26"><a href="#cb10-26"></a>                        <span class="cf">return</span> x3;</span>
<span id="cb10-27"><a href="#cb10-27"></a>                    }</span>
<span id="cb10-28"><a href="#cb10-28"></a>                } <span class="cf">else</span> { <span class="co">// w0 -&gt;</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>                    {   gc_frame0(gc,<span class="dv">1</span>,v55102202);</span>
<span id="cb10-30"><a href="#cb10-30"></a>                        wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd15 &lt;- dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a1 = v55102202;</span>
<span id="cb10-32"><a href="#cb10-32"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a2 = v196335308;</span>
<span id="cb10-33"><a href="#cb10-33"></a>                        wptr_t v15 = x4;</span>
<span id="cb10-34"><a href="#cb10-34"></a>                        sptr_t v1829124143 = demote(v15); <span class="co">// ni1829124143 &lt;- demote nd15</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>                        v80100072 = v40405746; <span class="co">// fW@.fR@.fJhc.Inst.Show.showWord w40405746 ni1829124143</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>                        v196335308 = v1829124143;</span>
<span id="cb10-37"><a href="#cb10-37"></a>                        <span class="cf">goto</span> fW$__fR$__fJhc_Inst_Show_showWord__2;</span>
<span id="cb10-38"><a href="#cb10-38"></a>                    }</span>
<span id="cb10-39"><a href="#cb10-39"></a>                }</span>
<span id="cb10-40"><a href="#cb10-40"></a>            }</span>
<span id="cb10-41"><a href="#cb10-41"></a>        }</span>
<span id="cb10-42"><a href="#cb10-42"></a>}</span></code></pre></div>
<p>C言語側にGrinコード断片をコメントで入れてみたでゲソ。 だいたい1対1に対応が取れているじゃなイカ。 ここではGrinとC言語の違いに着目して、そのしくみを詳しく見てみるでゲソ。</p>
<p>まず第一にdstore (CJhc.Type.Basic.Char,x)がRAW_SET_UF(x)になることがあるでゲソ。 このRAW_SET_UF()はイカのような定義で、即値のWHNFに変換してくれるでゲソ。 CJhc.Type.Basic.Charは即値なので、RAW_SET_UF()を使ってスマートポインタに埋め込まれるんじゃなイカ。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) &lt;&lt; 2) | P_VALUE))</span></span></code></pre></div>
<p>ところがdstore (CJhc.Prim.Prim.: x y) のような場合にはイカのようにs_alloc()でヒープへのスマートポインタを作って、 格納するでゲソ。 これはHaskellの(:)演算子を思いうかべればすぐわかるでゲソ。 (:)演算子は2つの要素をconsし、 そのconsした結果がstruct sCJhc_Prim_Prim_$x3aなんでゲソ。 つまりconsする旅にヒープの領域を消費するということでゲソ。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {</span>
<span id="cb12-2"><a href="#cb12-2"></a>    sptr_t a1;</span>
<span id="cb12-3"><a href="#cb12-3"></a>    sptr_t a2;</span>
<span id="cb12-4"><a href="#cb12-4"></a>};</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a);</span>
<span id="cb12-7"><a href="#cb12-7"></a>((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a1 = x;</span>
<span id="cb12-8"><a href="#cb12-8"></a>((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x4)-&gt;a2 = y;</span></code></pre></div>
<p>最後にfW@.fR@.fJhc.Inst.Show.showWord関数の再帰がgotoループになっているでゲソ。 たまたまこの関数の例はすぐにループ化できる再帰だから良かったでゲソ。 しかし、原理的に全ての再帰がループ化されるのカ？少し不安でゲソ…</p>
<h3 id="func-fjhc.show.shows-ii---n">4. Func: fJhc.Show.shows :: (I,I) -&gt; (N)</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- Grin --</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="fu">shows</span><span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb13-3"><a href="#cb13-3"></a>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="fu">shows</span> ni29375120 ni44000678 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  withRoots(ni44000678)</span>
<span id="cb13-5"><a href="#cb13-5"></a>    nd100038 <span class="ot">&lt;-</span> eval ni29375120</span>
<span id="cb13-6"><a href="#cb13-6"></a>    (<span class="dt">CJhc.Type.Word.Int</span> w216085094) <span class="ot">&lt;-</span> <span class="fu">return</span> nd100038</span>
<span id="cb13-7"><a href="#cb13-7"></a>    h100040 <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="ot">`Gt`</span> w216085094</span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="kw">case</span> h100040 <span class="kw">of</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>        w196289068 <span class="ot">&lt;-</span> (bits32)<span class="dt">Neg</span> w216085094</span>
<span id="cb13-11"><a href="#cb13-11"></a>        bm253468954 <span class="ot">&lt;-</span> (bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Sx</span> bits32 w196289068</span>
<span id="cb13-12"><a href="#cb13-12"></a>        w124235152 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span> bm253468954</span>
<span id="cb13-13"><a href="#cb13-13"></a>        ni244126258 <span class="ot">&lt;-</span> istore (<span class="dt">FW</span><span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w124235152 ni44000678)</span>
<span id="cb13-14"><a href="#cb13-14"></a>        withRoots(ni244126258)</span>
<span id="cb13-15"><a href="#cb13-15"></a>          dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">45</span>) ni244126258)</span>
<span id="cb13-16"><a href="#cb13-16"></a>      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-17"><a href="#cb13-17"></a>        bm220263214 <span class="ot">&lt;-</span> (bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span>)<span class="dt">ConvOp</span> <span class="dt">Sx</span> bits32 w216085094</span>
<span id="cb13-18"><a href="#cb13-18"></a>        w110207578 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">Lobits</span> bits<span class="op">&lt;</span><span class="fu">max</span><span class="op">&gt;</span> bm220263214</span>
<span id="cb13-19"><a href="#cb13-19"></a>        fW<span class="op">@.</span>fJhc<span class="op">.</span>Inst.Show.showWord w110207578 ni44000678</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb14-3"><a href="#cb14-3"></a>fJhc_Show_shows(gc_t gc,sptr_t v29375120,sptr_t v44000678)</span>
<span id="cb14-4"><a href="#cb14-4"></a>{</span>
<span id="cb14-5"><a href="#cb14-5"></a>        {   <span class="dt">uint32_t</span> v216085094;</span>
<span id="cb14-6"><a href="#cb14-6"></a>            gc_frame0(gc,<span class="dv">1</span>,v44000678); <span class="co">// withRoots(ni44000678)</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>            wptr_t v100038 = eval(gc,v29375120); <span class="co">// nd100038 &lt;- eval ni29375120</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>            v216085094 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100038)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w216085094) &lt;- return nd100038</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>            <span class="dt">uint16_t</span> v100040 = (((<span class="dt">int32_t</span>)<span class="dv">0</span>) &gt; ((<span class="dt">int32_t</span>)v216085094)); <span class="co">// h100040 &lt;- 0 `Gt` w216085094</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>            <span class="cf">if</span> (<span class="dv">0</span> == v100040) { <span class="co">// case h100040 of 0 -&gt; do</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>                <span class="dt">uintmax_t</span> v220263214 = ((<span class="dt">intmax_t</span>)((<span class="dt">int32_t</span>)v216085094)); <span class="co">// bm220263214 &lt;- (bits&lt;max&gt;)ConvOp Sx bits32 w216085094</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>                <span class="dt">uint32_t</span> v110207578 = ((<span class="dt">uint32_t</span>)v220263214); <span class="co">// w110207578 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm220263214</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>                <span class="cf">return</span> fW$__fJhc_Inst_Show_showWord(gc,v110207578,v44000678); <span class="co">// fW@.fJhc.Inst.Show.showWord w110207578 ni44000678</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>            } <span class="cf">else</span> { <span class="co">// 1 -&gt; do</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>                <span class="co">/* 1 */</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>                assert(<span class="dv">1</span> == v100040);</span>
<span id="cb14-17"><a href="#cb14-17"></a>                <span class="dt">uint32_t</span> v196289068 = (-((<span class="dt">int32_t</span>)v216085094)); <span class="co">// w196289068 &lt;- (bits32)Neg w216085094</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>                <span class="dt">uintmax_t</span> v253468954 = ((<span class="dt">intmax_t</span>)((<span class="dt">int32_t</span>)v196289068)); <span class="co">// bm253468954 &lt;- (bits&lt;max&gt;)ConvOp Sx bits32 w196289068</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>                <span class="dt">uint32_t</span> v124235152 = ((<span class="dt">uint32_t</span>)v253468954); <span class="co">// w124235152 &lt;- (bits32)ConvOp Lobits bits&lt;max&gt; bm253468954</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>                sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord); <span class="co">// ni244126258 &lt;- istore (FW@.fJhc.Inst.Show.showWord w124235152 ni44000678)</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;head = TO_FPTR(&amp;E__fW$__fJhc_Inst_Show_showWord);</span>
<span id="cb14-22"><a href="#cb14-22"></a>                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a1 = v124235152;</span>
<span id="cb14-23"><a href="#cb14-23"></a>                ((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a2 = v44000678;</span>
<span id="cb14-24"><a href="#cb14-24"></a>                sptr_t v244126258 = MKLAZY(x5);</span>
<span id="cb14-25"><a href="#cb14-25"></a>                {   gc_frame0(gc,<span class="dv">1</span>,v244126258); <span class="co">// withRoots(ni244126258)</span></span>
<span id="cb14-26"><a href="#cb14-26"></a>                    wptr_t x6 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: &amp;(CJhc.Type.Basic.Char 45) ni244126258)</span></span>
<span id="cb14-27"><a href="#cb14-27"></a>                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x6)-&gt;a1 = ((sptr_t)RAW_SET_UF(<span class="ch">'-'</span>));</span>
<span id="cb14-28"><a href="#cb14-28"></a>                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x6)-&gt;a2 = v244126258;</span>
<span id="cb14-29"><a href="#cb14-29"></a>                    <span class="cf">return</span> x6;</span>
<span id="cb14-30"><a href="#cb14-30"></a>                }</span>
<span id="cb14-31"><a href="#cb14-31"></a>            }</span>
<span id="cb14-32"><a href="#cb14-32"></a>        }</span>
<span id="cb14-33"><a href="#cb14-33"></a>}</span></code></pre></div>
<p>これもほぼ1対1に対応しているでゲソが、唯一の例外が istore (FW@.fJhc.Inst.Show.showWord x y) がs_alloc()によるヒープの確保に化けることでゲソ。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord {</span>
<span id="cb15-2"><a href="#cb15-2"></a>    fptr_t head;</span>
<span id="cb15-3"><a href="#cb15-3"></a>    sptr_t a2;</span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">uint32_t</span> a1;</span>
<span id="cb15-5"><a href="#cb15-5"></a>};</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a>sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord);</span>
<span id="cb15-8"><a href="#cb15-8"></a>((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;head = TO_FPTR(&amp;E__fW$__fJhc_Inst_Show_showWord);</span>
<span id="cb15-9"><a href="#cb15-9"></a>((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a1 = x;</span>
<span id="cb15-10"><a href="#cb15-10"></a>((<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord*)x5)-&gt;a2 = y;</span>
<span id="cb15-11"><a href="#cb15-11"></a>sptr_t v244126258 = MKLAZY(x5);</span></code></pre></div>
<p>この謎はjhcのjhcライブラリのソース見れば理解できるでゲソ。 showWord関数はイカのように通常のLazyな関数じゃなイカ。 ということはここでは未評価サンクだけ作り後で誰かがforceしてくれるのを待てばいいんでゲソ。 ここで作成する未評価サンクの実体がstruct sFW$__fJhc_Inst_Show_showWordで、 やはりヒープに確保されるでゲソ。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">-- jhc/lib/jhc/Jhc/Inst/Show.hs</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="ot">showWord ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>showWord w rest <span class="ot">=</span> w <span class="ot">`seq`</span> <span class="kw">case</span> <span class="fu">quotRem</span> w <span class="dv">10</span> <span class="kw">of</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    (n',d) <span class="ot">-&gt;</span> n' <span class="ot">`seq`</span> d <span class="ot">`seq`</span> rest' <span class="ot">`seq`</span> <span class="kw">if</span> n' <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> rest' <span class="kw">else</span> showWord n' rest'</span>
<span id="cb16-5"><a href="#cb16-5"></a>        <span class="kw">where</span> rest' <span class="ot">=</span> <span class="fu">chr</span> (<span class="fu">fromIntegral</span> d <span class="op">+</span> <span class="fu">ord</span> <span class="ch">'0'</span>) <span class="op">:</span> rest</span></code></pre></div>
<h3 id="func-fr.fjhc.show.11_showl-in---n">5. Func: fR@.fJhc.Show.11_showl :: (I,N) -&gt; (N)</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">-- Grin --</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="dv">11</span><span class="ot">_showl ::</span> (<span class="dt">I</span>,<span class="dt">N</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="dv">11</span>_showl ni108431528 nd267777212 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>  ni267777293 <span class="ot">&lt;-</span> demote nd267777212</span>
<span id="cb17-5"><a href="#cb17-5"></a>  withRoots(nd267777212,ni267777293)</span>
<span id="cb17-6"><a href="#cb17-6"></a>    nd100036 <span class="ot">&lt;-</span> eval ni108431528</span>
<span id="cb17-7"><a href="#cb17-7"></a>    (ni126,ni95) <span class="ot">&lt;-</span> <span class="kw">case</span> nd100036 <span class="kw">of</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>      (<span class="op">CJhc.Prim.Prim.:</span> ni26 ni67) <span class="ot">-&gt;</span> withRoots(ni26,ni67)</span>
<span id="cb17-9"><a href="#cb17-9"></a>        ni110947984 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="dv">11</span>_showl ni67 nd267777212)</span>
<span id="cb17-10"><a href="#cb17-10"></a>        withRoots(ni110947984)</span>
<span id="cb17-11"><a href="#cb17-11"></a>          ni215884490 <span class="ot">&lt;-</span> istore (FJhc.Show.shows ni26 ni110947984)</span>
<span id="cb17-12"><a href="#cb17-12"></a>          <span class="fu">return</span> (<span class="op">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">44</span>),ni215884490)</span>
<span id="cb17-13"><a href="#cb17-13"></a>      [] <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="op">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">93</span>),ni267777293)</span>
<span id="cb17-14"><a href="#cb17-14"></a>    withRoots(ni95,ni126)</span>
<span id="cb17-15"><a href="#cb17-15"></a>      dstore (<span class="op">CJhc.Prim.Prim.:</span> ni126 ni95)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb18-3"><a href="#cb18-3"></a>fR$__fJhc_Show_11__showl(gc_t gc,sptr_t v108431528,wptr_t v267777212)</span>
<span id="cb18-4"><a href="#cb18-4"></a>{</span>
<span id="cb18-5"><a href="#cb18-5"></a>        sptr_t v267777293 = demote(v267777212); <span class="co">// ni267777293 &lt;- demote nd267777212</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>        {   sptr_t v126;</span>
<span id="cb18-7"><a href="#cb18-7"></a>            sptr_t v95;</span>
<span id="cb18-8"><a href="#cb18-8"></a>            <span class="kw">struct</span> tup1 x7;</span>
<span id="cb18-9"><a href="#cb18-9"></a>            gc_frame0(gc,<span class="dv">2</span>,v267777212,v267777293); <span class="co">// withRoots(nd267777212,ni267777293)</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>            wptr_t v100036 = eval(gc,v108431528); <span class="co">// nd100036 &lt;- eval ni108431528</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>            <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100036) { <span class="co">// case nd100036 of [] -&gt;</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>                x7.t0 = ((sptr_t)RAW_SET_UF(<span class="ch">']'</span>)); <span class="co">// return (&amp;(CJhc.Type.Basic.Char 93),ni267777293)</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>                x7.t1 = v267777293;</span>
<span id="cb18-14"><a href="#cb18-14"></a>            } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni26 ni67) -&gt;</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>                sptr_t v26;</span>
<span id="cb18-16"><a href="#cb18-16"></a>                sptr_t v67;</span>
<span id="cb18-17"><a href="#cb18-17"></a>                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni26 ni67) パターンマッチ */</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>                v26 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100036)-&gt;a1;</span>
<span id="cb18-19"><a href="#cb18-19"></a>                v67 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100036)-&gt;a2;</span>
<span id="cb18-20"><a href="#cb18-20"></a>                {   gc_frame0(gc,<span class="dv">2</span>,v26,v67); <span class="co">// withRoots(ni26,ni67)</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>                    sptr_t x8 = s_alloc(gc,cFR$__fJhc_Show_11__showl); <span class="co">// ni110947984 &lt;- istore (FR@.fJhc.Show.11_showl ni67 nd267777212)</span></span>
<span id="cb18-22"><a href="#cb18-22"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Show_11__showl);</span>
<span id="cb18-23"><a href="#cb18-23"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;a1 = v67;</span>
<span id="cb18-24"><a href="#cb18-24"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x8)-&gt;a2 = v267777212;</span>
<span id="cb18-25"><a href="#cb18-25"></a>                    sptr_t v110947984 = MKLAZY(x8);</span>
<span id="cb18-26"><a href="#cb18-26"></a>                    {   gc_frame0(gc,<span class="dv">1</span>,v110947984); <span class="co">// withRoots(ni110947984)</span></span>
<span id="cb18-27"><a href="#cb18-27"></a>                        sptr_t x9 = s_alloc(gc,cFJhc_Show_shows); <span class="co">// ni215884490 &lt;- istore (FJhc.Show.shows ni26 ni110947984)</span></span>
<span id="cb18-28"><a href="#cb18-28"></a>                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;head = TO_FPTR(&amp;E__fJhc_Show_shows);</span>
<span id="cb18-29"><a href="#cb18-29"></a>                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;a1 = v26;</span>
<span id="cb18-30"><a href="#cb18-30"></a>                        ((<span class="kw">struct</span> sFJhc_Show_shows*)x9)-&gt;a2 = v110947984;</span>
<span id="cb18-31"><a href="#cb18-31"></a>                        sptr_t v215884490 = MKLAZY(x9);</span>
<span id="cb18-32"><a href="#cb18-32"></a>                        x7.t0 = ((sptr_t)RAW_SET_UF(<span class="ch">','</span>)); <span class="co">// return (&amp;(CJhc.Type.Basic.Char 44),ni215884490)</span></span>
<span id="cb18-33"><a href="#cb18-33"></a>                        x7.t1 = v215884490;</span>
<span id="cb18-34"><a href="#cb18-34"></a>                    }</span>
<span id="cb18-35"><a href="#cb18-35"></a>                }</span>
<span id="cb18-36"><a href="#cb18-36"></a>            }</span>
<span id="cb18-37"><a href="#cb18-37"></a>            v126 = x7.t0; <span class="co">// (ni126,ni95) &lt;-</span></span>
<span id="cb18-38"><a href="#cb18-38"></a>            v95 = x7.t1;</span>
<span id="cb18-39"><a href="#cb18-39"></a>            {   gc_frame0(gc,<span class="dv">2</span>,v95,v126); <span class="co">// withRoots(ni95,ni126)</span></span>
<span id="cb18-40"><a href="#cb18-40"></a>                wptr_t x10 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni126 ni95)</span></span>
<span id="cb18-41"><a href="#cb18-41"></a>                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x10)-&gt;a1 = v126;</span>
<span id="cb18-42"><a href="#cb18-42"></a>                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x10)-&gt;a2 = v95;</span>
<span id="cb18-43"><a href="#cb18-43"></a>                <span class="cf">return</span> x10;</span>
<span id="cb18-44"><a href="#cb18-44"></a>            }</span>
<span id="cb18-45"><a href="#cb18-45"></a>        }</span>
<span id="cb18-46"><a href="#cb18-46"></a>}</span></code></pre></div>
<p>ここまで来るとほぼこれまで仕入れた知識で読めるでゲソ! 新しく出てきた表現をあえて挙げるならタプルでゲソ。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">struct</span> tup1 {</span>
<span id="cb19-2"><a href="#cb19-2"></a>    sptr_t t0;</span>
<span id="cb19-3"><a href="#cb19-3"></a>    sptr_t t1;</span>
<span id="cb19-4"><a href="#cb19-4"></a>};</span></code></pre></div>
<p>これはもう見たままでゲソ。タプルじゃなイカ。 ところでなんでいきなりタプルを使うことになったんでゲソ？</p>
<p>この関数はjhcライブラリのshowList関数の中にあるshowlローカル関数に由来しているでゲソ。 どうもShowS型の合成を (文字,サンク) というタプルでの表現に変換しているようじゃなイカ。 コンパイルパイプラインの最適化のどこでこの変換が行なわれるのか興味が出てきたでゲソ。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">-- jhc/lib/jhc/Jhc/Show.hs</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">type</span>  <span class="dt">ShowS</span>    <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">class</span>  <span class="dt">Show</span> a  <span class="kw">where</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">-- snip --</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="ot">    showList         ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">-- snip --</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="fu">showList</span> []       <span class="ot">=</span> <span class="fu">showString</span> <span class="st">&quot;[]&quot;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="fu">showList</span> (x<span class="op">:</span>xs)   <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">'['</span> <span class="op">.</span> <span class="fu">shows</span> x <span class="op">.</span> showl xs</span>
<span id="cb20-10"><a href="#cb20-10"></a>                        <span class="kw">where</span> showl []     <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">']'</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>                              showl (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">','</span> <span class="op">.</span> <span class="fu">shows</span> x <span class="op">.</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>                                             showl xs</span></code></pre></div>
<h3 id="func-fthemain2-ii---n">6. Func: ftheMain$2 :: (I,I) -&gt; (N)</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="co">-- Grin --</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>ftheMain<span class="op">$</span><span class="dv">2</span><span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a>ftheMain<span class="op">$</span><span class="dv">2</span> ni38 ni42 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>  withRoots(ni42)</span>
<span id="cb21-5"><a href="#cb21-5"></a>    nd100032 <span class="ot">&lt;-</span> eval ni38</span>
<span id="cb21-6"><a href="#cb21-6"></a>    withRoots(nd100032)</span>
<span id="cb21-7"><a href="#cb21-7"></a>      nd100092 <span class="ot">&lt;-</span> eval ni42</span>
<span id="cb21-8"><a href="#cb21-8"></a>      (<span class="dt">CJhc.Type.Word.Int</span> w239029634) <span class="ot">&lt;-</span> <span class="fu">return</span> nd100032</span>
<span id="cb21-9"><a href="#cb21-9"></a>      (<span class="dt">CJhc.Type.Word.Int</span> w242159974) <span class="ot">&lt;-</span> <span class="fu">return</span> nd100092</span>
<span id="cb21-10"><a href="#cb21-10"></a>      w215350916 <span class="ot">&lt;-</span> w239029634 <span class="op">+</span> w242159974</span>
<span id="cb21-11"><a href="#cb21-11"></a>      dstore (<span class="dt">CJhc.Type.Word.Int</span> w215350916)</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb22-3"><a href="#cb22-3"></a>ftheMain$d2(gc_t gc,sptr_t v38,sptr_t v42)</span>
<span id="cb22-4"><a href="#cb22-4"></a>{</span>
<span id="cb22-5"><a href="#cb22-5"></a>        {   gc_frame0(gc,<span class="dv">1</span>,v42); <span class="co">// withRoots(ni42)</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>            wptr_t v100032 = eval(gc,v38); <span class="co">// nd100032 &lt;- eval ni38</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>            {   <span class="dt">uint32_t</span> v239029634;</span>
<span id="cb22-8"><a href="#cb22-8"></a>                <span class="dt">uint32_t</span> v242159974;</span>
<span id="cb22-9"><a href="#cb22-9"></a>                gc_frame0(gc,<span class="dv">1</span>,v100032); <span class="co">// withRoots(nd100032)</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>                wptr_t v100092 = eval(gc,v42); <span class="co">// nd100092 &lt;- eval ni42</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>                v239029634 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100032)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w239029634) &lt;- return nd100032</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>                v242159974 = ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100092)-&gt;a1; <span class="co">// (CJhc.Type.Word.Int w242159974) &lt;- return nd100092</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>                <span class="dt">uint32_t</span> v215350916 = (v239029634 + v242159974); <span class="co">// w215350916 &lt;- w239029634 + w242159974</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>                wptr_t x11 = s_alloc(gc,cCJhc_Type_Word_Int); <span class="co">// dstore (CJhc.Type.Word.Int w215350916)</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>                ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)x11)-&gt;a1 = v215350916;</span>
<span id="cb22-16"><a href="#cb22-16"></a>                <span class="cf">return</span> x11;</span>
<span id="cb22-17"><a href="#cb22-17"></a>            }</span>
<span id="cb22-18"><a href="#cb22-18"></a>        }</span>
<span id="cb22-19"><a href="#cb22-19"></a>}</span></code></pre></div>
<p>ここではじめて“+”演算子を使っているでゲソ。 中間に変数をはさんでいるのでわかりにくいでゲソが、全部展開するとイカのような処理のはずでゲソ。 jhcではプリミティブ型が則、C言語のプリミティブ型に落ちるので、こんな芸当ができるんでゲソ!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">struct</span> sCJhc_Type_Word_Int {</span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="dt">uint32_t</span> a1;</span>
<span id="cb23-3"><a href="#cb23-3"></a>};</span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>((<span class="kw">struct</span> sCJhc_Type_Word_Int*)x11)-&gt;a1 =</span>
<span id="cb23-6"><a href="#cb23-6"></a>  ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100032)-&gt;a1 + ((<span class="kw">struct</span> sCJhc_Type_Word_Int*)v100092)-&gt;a1;</span></code></pre></div>
<h3 id="func-fr.fjhc.basics.-in---n">7. Func: fR@.fJhc.Basics.++ :: (I,N) -&gt; (N)</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">-- Grin --</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>fR<span class="op">@.</span>fJhc<span class="op">.Basics.++</span><span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">N</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb24-3"><a href="#cb24-3"></a>fR<span class="op">@.</span>fJhc<span class="op">.Basics.++</span> ni29534742 nd29534740 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  withRoots(nd29534740)</span>
<span id="cb24-5"><a href="#cb24-5"></a>    nd100000 <span class="ot">&lt;-</span> eval ni29534742</span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="kw">case</span> nd100000 <span class="kw">of</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>      (<span class="op">CJhc.Prim.Prim.:</span> ni106 ni108) <span class="ot">-&gt;</span> withRoots(ni106,ni108)</span>
<span id="cb24-8"><a href="#cb24-8"></a>        ni69834446 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.Basics.++</span> ni108 nd29534740)</span>
<span id="cb24-9"><a href="#cb24-9"></a>        withRoots(ni69834446)</span>
<span id="cb24-10"><a href="#cb24-10"></a>          dstore (<span class="op">CJhc.Prim.Prim.:</span> ni106 ni69834446)</span>
<span id="cb24-11"><a href="#cb24-11"></a>      [] <span class="ot">-&gt;</span> <span class="fu">return</span> nd29534740</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb25-3"><a href="#cb25-3"></a>fR$__fJhc_Basics_$pp(gc_t gc,sptr_t v29534742,wptr_t v29534740)</span>
<span id="cb25-4"><a href="#cb25-4"></a>{</span>
<span id="cb25-5"><a href="#cb25-5"></a>        {   gc_frame0(gc,<span class="dv">1</span>,v29534740); <span class="co">// withRoots(nd29534740)</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>            wptr_t v100000 = eval(gc,v29534742); <span class="co">// nd100000 &lt;- eval ni29534742</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>            <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100000) { <span class="co">// case nd100000 of [] -&gt;</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>                <span class="cf">return</span> v29534740; <span class="co">// return nd29534740</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>            } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni106 ni108) -&gt;</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>                sptr_t v106;</span>
<span id="cb25-11"><a href="#cb25-11"></a>                sptr_t v108;</span>
<span id="cb25-12"><a href="#cb25-12"></a>                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni106 ni108) パターンマッチ */</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>                v106 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100000)-&gt;a1;</span>
<span id="cb25-14"><a href="#cb25-14"></a>                v108 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100000)-&gt;a2;</span>
<span id="cb25-15"><a href="#cb25-15"></a>                {   gc_frame0(gc,<span class="dv">2</span>,v106,v108); <span class="co">// withRoots(ni106,ni108)</span></span>
<span id="cb25-16"><a href="#cb25-16"></a>                    sptr_t x12 = s_alloc(gc,cFR$__fJhc_Basics_$pp); <span class="co">// ni69834446 &lt;- istore (FR@.fJhc.Basics.++ ni108 nd29534740)</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_$pp);</span>
<span id="cb25-18"><a href="#cb25-18"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;a1 = v108;</span>
<span id="cb25-19"><a href="#cb25-19"></a>                    ((<span class="kw">struct</span> sFR$__fJhc_Basics_$pp*)x12)-&gt;a2 = v29534740;</span>
<span id="cb25-20"><a href="#cb25-20"></a>                    sptr_t v69834446 = MKLAZY(x12);</span>
<span id="cb25-21"><a href="#cb25-21"></a>                    {   gc_frame0(gc,<span class="dv">1</span>,v69834446); <span class="co">// withRoots(ni69834446)</span></span>
<span id="cb25-22"><a href="#cb25-22"></a>                        wptr_t x13 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni106 ni69834446)</span></span>
<span id="cb25-23"><a href="#cb25-23"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x13)-&gt;a1 = v106;</span>
<span id="cb25-24"><a href="#cb25-24"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x13)-&gt;a2 = v69834446;</span>
<span id="cb25-25"><a href="#cb25-25"></a>                        <span class="cf">return</span> x13;</span>
<span id="cb25-26"><a href="#cb25-26"></a>                    }</span>
<span id="cb25-27"><a href="#cb25-27"></a>                }</span>
<span id="cb25-28"><a href="#cb25-28"></a>            }</span>
<span id="cb25-29"><a href="#cb25-29"></a>        }</span>
<span id="cb25-30"><a href="#cb25-30"></a>}</span></code></pre></div>
<p>この関数はこれまでの調査結果で理解できるでゲソ。</p>
<h3 id="func-fthemain3---n">8. Func: ftheMain$3 :: () -&gt; (N)</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="co">-- Grin --</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>ftheMain<span class="op">$</span><span class="dv">3</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb26-3"><a href="#cb26-3"></a>ftheMain<span class="op">$</span><span class="dv">3</span>  <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  fR<span class="op">@.</span>fJhc<span class="op">.Basics.++</span> <span class="op">&amp;</span><span class="st">&quot;[]&quot;</span> []</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {</span>
<span id="cb27-3"><a href="#cb27-3"></a>    sptr_t a1;</span>
<span id="cb27-4"><a href="#cb27-4"></a>    sptr_t a2;</span>
<span id="cb27-5"><a href="#cb27-5"></a>};</span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="pp">#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) &lt;&lt; 2) | P_VALUE))</span></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="pp">#define RAW_SET_16(w)  (wptr_t)(((uintptr_t)(w) &lt;&lt; 16) | P_VALUE)</span></span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="pp">#define SET_RAW_TAG(x)    RAW_SET_16(x)</span></span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a><span class="kw">enum</span> {</span>
<span id="cb27-12"><a href="#cb27-12"></a>    CJhc_Prim_Prim_$BE = <span class="dv">1</span>,</span>
<span id="cb27-13"><a href="#cb27-13"></a>    CJhc_Prim_Prim_$LR = <span class="dv">0</span>,</span>
<span id="cb27-14"><a href="#cb27-14"></a>    CJhc_Prim_Prim_$x3a = <span class="dv">0</span>,</span>
<span id="cb27-15"><a href="#cb27-15"></a>    CJhc_Type_Basic_Char = <span class="dv">0</span>,</span>
<span id="cb27-16"><a href="#cb27-16"></a>    CJhc_Type_Word_Int = <span class="dv">0</span></span>
<span id="cb27-17"><a href="#cb27-17"></a>};</span>
<span id="cb27-18"><a href="#cb27-18"></a></span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="co">/* (HcNode CJhc.Prim.Prim.: [Left &amp;(&quot;CJhc.Type.Basic.Char&quot; 93),Left &amp;(&quot;CJhc.Prim.Prim.[]&quot;)],1) */</span></span>
<span id="cb27-20"><a href="#cb27-20"></a><span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> sCJhc_Prim_Prim_$x3a _c1 = {.a1 = (sptr_t)RAW_SET_UF(<span class="ch">']'</span>), .a2 = (sptr_t)SET_RAW_TAG(CJhc_Prim_Prim_$BE)};</span>
<span id="cb27-21"><a href="#cb27-21"></a><span class="pp">#define c1 (TO_SPTR_C(P_WHNF, (sptr_t)&amp;_c1))</span></span>
<span id="cb27-22"><a href="#cb27-22"></a><span class="co">/* (HcNode CJhc.Prim.Prim.: [Left &amp;(&quot;CJhc.Type.Basic.Char&quot; 91),Right 1],2) */</span></span>
<span id="cb27-23"><a href="#cb27-23"></a><span class="dt">static</span> <span class="dt">const</span> <span class="kw">struct</span> sCJhc_Prim_Prim_$x3a _c2 = {.a1 = (sptr_t)RAW_SET_UF(<span class="ch">'['</span>), .a2 = c1};</span>
<span id="cb27-24"><a href="#cb27-24"></a><span class="pp">#define c2 (TO_SPTR_C(P_WHNF, (sptr_t)&amp;_c2))</span></span>
<span id="cb27-25"><a href="#cb27-25"></a></span>
<span id="cb27-26"><a href="#cb27-26"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb27-27"><a href="#cb27-27"></a>ftheMain$d3(gc_t gc)</span>
<span id="cb27-28"><a href="#cb27-28"></a>{</span>
<span id="cb27-29"><a href="#cb27-29"></a>        <span class="cf">return</span> fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));</span>
<span id="cb27-30"><a href="#cb27-30"></a>}</span></code></pre></div>
<p>いきなりc2というグローバル変数が出てきたじゃなイカ。これはなんでゲソ？</p>
<p><img src="../draw/2013-02-17-jhc_grin_to_c_c2.png" /></p>
<p>なるほどたしかに fR@.fJhc.Basics.++ &amp;“[]” [] とあったので“[]”という文字列が欲しかったんでゲソね。</p>
<h3 id="func-fr.fjhc.basics.zipwith-ii---n">9. Func: fR@.fJhc.Basics.zipWith :: (I,I) -&gt; (N)</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="co">-- Grin --</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>fR<span class="op">@.</span>fJhc<span class="op">.</span>Basics.zipWith<span class="ot"> ::</span> (<span class="dt">I</span>,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb28-3"><a href="#cb28-3"></a>fR<span class="op">@.</span>fJhc<span class="op">.</span>Basics.zipWith ni182639120 ni132127014 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>  withRoots(ni132127014)</span>
<span id="cb28-5"><a href="#cb28-5"></a>    nd100028 <span class="ot">&lt;-</span> eval ni182639120</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="kw">case</span> nd100028 <span class="kw">of</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>      (<span class="op">CJhc.Prim.Prim.:</span> ni40405740 ni40) <span class="ot">-&gt;</span> withRoots(ni40,ni40405740)</span>
<span id="cb28-8"><a href="#cb28-8"></a>        nd100030 <span class="ot">&lt;-</span> eval ni132127014</span>
<span id="cb28-9"><a href="#cb28-9"></a>        <span class="kw">case</span> nd100030 <span class="kw">of</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>          (<span class="op">CJhc.Prim.Prim.:</span> ni194635132 ni116) <span class="ot">-&gt;</span> withRoots(ni116,ni194635132)</span>
<span id="cb28-11"><a href="#cb28-11"></a>            ni248061794 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.</span>Basics.zipWith ni40 ni116)</span>
<span id="cb28-12"><a href="#cb28-12"></a>            withRoots(ni248061794)</span>
<span id="cb28-13"><a href="#cb28-13"></a>              ni229109160 <span class="ot">&lt;-</span> istore (<span class="dt">FtheMain</span><span class="op">$</span><span class="dv">2</span> ni40405740 ni194635132)</span>
<span id="cb28-14"><a href="#cb28-14"></a>              withRoots(ni229109160)</span>
<span id="cb28-15"><a href="#cb28-15"></a>                dstore (<span class="op">CJhc.Prim.Prim.:</span> ni229109160 ni248061794)</span>
<span id="cb28-16"><a href="#cb28-16"></a>          [] <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb28-17"><a href="#cb28-17"></a>      [] <span class="ot">-&gt;</span> <span class="fu">return</span> []</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb29-3"><a href="#cb29-3"></a>fR$__fJhc_Basics_zipWith(gc_t gc,sptr_t v182639120,sptr_t v132127014)</span>
<span id="cb29-4"><a href="#cb29-4"></a>{</span>
<span id="cb29-5"><a href="#cb29-5"></a>        {   gc_frame0(gc,<span class="dv">1</span>,v132127014); <span class="co">// withRoots(ni132127014)</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>            wptr_t v100028 = eval(gc,v182639120); <span class="co">// nd100028 &lt;- eval ni182639120</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>            <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100028) { <span class="co">// case nd100028 of [] -&gt;</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>                <span class="cf">return</span> v100028; <span class="co">// return []</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>            } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni40405740 ni40) -&gt;</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>                sptr_t v40;</span>
<span id="cb29-11"><a href="#cb29-11"></a>                sptr_t v40405740;</span>
<span id="cb29-12"><a href="#cb29-12"></a>                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni40405740 ni40) パターンマッチ */</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>                v40405740 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100028)-&gt;a1;</span>
<span id="cb29-14"><a href="#cb29-14"></a>                v40 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100028)-&gt;a2;</span>
<span id="cb29-15"><a href="#cb29-15"></a>                {   gc_frame0(gc,<span class="dv">2</span>,v40,v40405740); <span class="co">// withRoots(ni40,ni40405740)</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>                    wptr_t v100030 = eval(gc,v132127014); <span class="co">// nd100030 &lt;- eval ni132127014</span></span>
<span id="cb29-17"><a href="#cb29-17"></a>                    <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100030) { <span class="co">// case nd100030 of [] -&gt;</span></span>
<span id="cb29-18"><a href="#cb29-18"></a>                        <span class="cf">return</span> v100030; <span class="co">// return []</span></span>
<span id="cb29-19"><a href="#cb29-19"></a>                    } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni194635132 ni116) -&gt;</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>                        sptr_t v116;</span>
<span id="cb29-21"><a href="#cb29-21"></a>                        sptr_t v194635132;</span>
<span id="cb29-22"><a href="#cb29-22"></a>                        <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni194635132 ni116) パターンマッチ */</span></span>
<span id="cb29-23"><a href="#cb29-23"></a>                        v194635132 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100030)-&gt;a1;</span>
<span id="cb29-24"><a href="#cb29-24"></a>                        v116 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100030)-&gt;a2;</span>
<span id="cb29-25"><a href="#cb29-25"></a>                        {   gc_frame0(gc,<span class="dv">2</span>,v116,v194635132); <span class="co">// withRoots(ni116,ni194635132)</span></span>
<span id="cb29-26"><a href="#cb29-26"></a>                            sptr_t x14 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); <span class="co">// ni248061794 &lt;- istore (FR@.fJhc.Basics.zipWith ni40 ni116)</span></span>
<span id="cb29-27"><a href="#cb29-27"></a>                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith);</span>
<span id="cb29-28"><a href="#cb29-28"></a>                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;a1 = v40;</span>
<span id="cb29-29"><a href="#cb29-29"></a>                            ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x14)-&gt;a2 = v116;</span>
<span id="cb29-30"><a href="#cb29-30"></a>                            sptr_t v248061794 = MKLAZY(x14);</span>
<span id="cb29-31"><a href="#cb29-31"></a>                            {   gc_frame0(gc,<span class="dv">1</span>,v248061794); <span class="co">// withRoots(ni248061794)</span></span>
<span id="cb29-32"><a href="#cb29-32"></a>                                sptr_t x15 = s_alloc(gc,cFtheMain$d2); <span class="co">// ni229109160 &lt;- istore (FtheMain$2 ni40405740 ni194635132)</span></span>
<span id="cb29-33"><a href="#cb29-33"></a>                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;head = TO_FPTR(&amp;E__ftheMain$d2);</span>
<span id="cb29-34"><a href="#cb29-34"></a>                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;a1 = v40405740;</span>
<span id="cb29-35"><a href="#cb29-35"></a>                                ((<span class="kw">struct</span> sFtheMain$d2*)x15)-&gt;a2 = v194635132;</span>
<span id="cb29-36"><a href="#cb29-36"></a>                                sptr_t v229109160 = MKLAZY(x15);</span>
<span id="cb29-37"><a href="#cb29-37"></a>                                {   gc_frame0(gc,<span class="dv">1</span>,v229109160); <span class="co">// withRoots(ni229109160)</span></span>
<span id="cb29-38"><a href="#cb29-38"></a>                                    wptr_t x16 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni229109160 ni248061794)</span></span>
<span id="cb29-39"><a href="#cb29-39"></a>                                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x16)-&gt;a1 = v229109160;</span>
<span id="cb29-40"><a href="#cb29-40"></a>                                    ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x16)-&gt;a2 = v248061794;</span>
<span id="cb29-41"><a href="#cb29-41"></a>                                    <span class="cf">return</span> x16;</span>
<span id="cb29-42"><a href="#cb29-42"></a>                                }</span>
<span id="cb29-43"><a href="#cb29-43"></a>                            }</span>
<span id="cb29-44"><a href="#cb29-44"></a>                        }</span>
<span id="cb29-45"><a href="#cb29-45"></a>                    }</span>
<span id="cb29-46"><a href="#cb29-46"></a>                }</span>
<span id="cb29-47"><a href="#cb29-47"></a>            }</span>
<span id="cb29-48"><a href="#cb29-48"></a>        }</span>
<span id="cb29-49"><a href="#cb29-49"></a>}</span></code></pre></div>
<p>うむ。これも今の知識で読めるでゲソ。次の人!っでゲッソ。</p>
<h3 id="func-fw.fr.fjhc.list.387_f-bits32i---n">10. Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -&gt; (N)</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">-- Grin --</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">List</span><span class="op">.</span><span class="dv">387</span><span class="ot">_f ::</span> (bits32,<span class="dt">I</span>) <span class="ot">-&gt;</span> (<span class="dt">N</span>)</span>
<span id="cb30-3"><a href="#cb30-3"></a>fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">List</span><span class="op">.</span><span class="dv">387</span>_f w115160438 ni124940224 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>  h100024 <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="ot">`Gte`</span> w115160438</span>
<span id="cb30-5"><a href="#cb30-5"></a>  <span class="kw">case</span> h100024 <span class="kw">of</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>      nd100026 <span class="ot">&lt;-</span> eval ni124940224</span>
<span id="cb30-9"><a href="#cb30-9"></a>      <span class="kw">case</span> nd100026 <span class="kw">of</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>        (<span class="op">CJhc.Prim.Prim.:</span> ni304 ni306) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>          w194508206 <span class="ot">&lt;-</span> w115160438 <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb30-12"><a href="#cb30-12"></a>          withRoots(ni304,ni306)</span>
<span id="cb30-13"><a href="#cb30-13"></a>            ni131889104 <span class="ot">&lt;-</span> istore (<span class="dt">FW</span><span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">List</span><span class="op">.</span><span class="dv">387</span>_f w194508206 ni306)</span>
<span id="cb30-14"><a href="#cb30-14"></a>            withRoots(ni131889104)</span>
<span id="cb30-15"><a href="#cb30-15"></a>              dstore (<span class="op">CJhc.Prim.Prim.:</span> ni304 ni131889104)</span>
<span id="cb30-16"><a href="#cb30-16"></a>        [] <span class="ot">-&gt;</span> <span class="fu">return</span> []</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="dt">static</span> wptr_t A_STD A_MALLOC</span>
<span id="cb31-3"><a href="#cb31-3"></a>fW$__fR$__fJhc_List_387__f(gc_t gc,<span class="dt">uint32_t</span> v115160438,sptr_t v124940224)</span>
<span id="cb31-4"><a href="#cb31-4"></a>{</span>
<span id="cb31-5"><a href="#cb31-5"></a>        <span class="dt">uint16_t</span> v100024 = (((<span class="dt">int32_t</span>)<span class="dv">0</span>) &gt;= ((<span class="dt">int32_t</span>)v115160438)); <span class="co">// h100024 &lt;- 0 `Gte` w115160438</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>        <span class="cf">if</span> (<span class="dv">0</span> == v100024) { <span class="co">// case h100024 of 0 -&gt; do</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>            wptr_t v100026 = eval(gc,v124940224); <span class="co">// nd100026 &lt;- eval ni124940224</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>            <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100026) { <span class="co">// case nd100026 of [] -&gt;</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>                <span class="cf">return</span> v100026; <span class="co">// return []</span></span>
<span id="cb31-10"><a href="#cb31-10"></a>            } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni304 ni306) -&gt; do</span></span>
<span id="cb31-11"><a href="#cb31-11"></a>                sptr_t v304;</span>
<span id="cb31-12"><a href="#cb31-12"></a>                sptr_t v306;</span>
<span id="cb31-13"><a href="#cb31-13"></a>                <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni304 ni306) パターンマッチ */</span></span>
<span id="cb31-14"><a href="#cb31-14"></a>                v304 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100026)-&gt;a1;</span>
<span id="cb31-15"><a href="#cb31-15"></a>                v306 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100026)-&gt;a2;</span>
<span id="cb31-16"><a href="#cb31-16"></a>                <span class="dt">uint32_t</span> v194508206 = (v115160438 - <span class="dv">1</span>); <span class="co">// w194508206 &lt;- w115160438 - 1</span></span>
<span id="cb31-17"><a href="#cb31-17"></a>                {   gc_frame0(gc,<span class="dv">2</span>,v304,v306); <span class="co">// withRoots(ni304,ni306)</span></span>
<span id="cb31-18"><a href="#cb31-18"></a>                    sptr_t x17 = s_alloc(gc,cFW$__fR$__fJhc_List_387__f); <span class="co">// ni131889104 &lt;- istore (FW@.fR@.fJhc.List.387_f w194508206 ni306)</span></span>
<span id="cb31-19"><a href="#cb31-19"></a>                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;head = TO_FPTR(&amp;E__fW$__fR$__fJhc_List_387__f);</span>
<span id="cb31-20"><a href="#cb31-20"></a>                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;a1 = v194508206;</span>
<span id="cb31-21"><a href="#cb31-21"></a>                    ((<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f*)x17)-&gt;a2 = v306;</span>
<span id="cb31-22"><a href="#cb31-22"></a>                    sptr_t v131889104 = MKLAZY(x17);</span>
<span id="cb31-23"><a href="#cb31-23"></a>                    {   gc_frame0(gc,<span class="dv">1</span>,v131889104); <span class="co">// withRoots(ni131889104)</span></span>
<span id="cb31-24"><a href="#cb31-24"></a>                        wptr_t x18 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// dstore (CJhc.Prim.Prim.: ni304 ni131889104)</span></span>
<span id="cb31-25"><a href="#cb31-25"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x18)-&gt;a1 = v304;</span>
<span id="cb31-26"><a href="#cb31-26"></a>                        ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x18)-&gt;a2 = v131889104;</span>
<span id="cb31-27"><a href="#cb31-27"></a>                        <span class="cf">return</span> x18;</span>
<span id="cb31-28"><a href="#cb31-28"></a>                    }</span>
<span id="cb31-29"><a href="#cb31-29"></a>                }</span>
<span id="cb31-30"><a href="#cb31-30"></a>            }</span>
<span id="cb31-31"><a href="#cb31-31"></a>        } <span class="cf">else</span> { <span class="co">// 1 -&gt;</span></span>
<span id="cb31-32"><a href="#cb31-32"></a>            <span class="co">/* 1 */</span></span>
<span id="cb31-33"><a href="#cb31-33"></a>            assert(<span class="dv">1</span> == v100024);</span>
<span id="cb31-34"><a href="#cb31-34"></a>            <span class="cf">return</span> SET_RAW_TAG(CJhc_Prim_Prim_$BE); <span class="co">// return []</span></span>
<span id="cb31-35"><a href="#cb31-35"></a>        }</span>
<span id="cb31-36"><a href="#cb31-36"></a>}</span></code></pre></div>
<p>これも今までのパターンと同じでゲソ。もはや楽勝でゲソー。</p>
<h3 id="func-fthemain--">11. Func: ftheMain :: () -&gt; ()</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="co">-- Grin --</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="ot">ftheMain ::</span> () <span class="ot">-&gt;</span> ()</span>
<span id="cb32-3"><a href="#cb32-3"></a>ftheMain  <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>  nd163 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">?::</span><span class="dt">I</span> <span class="op">?::</span><span class="dt">I</span>)</span>
<span id="cb32-5"><a href="#cb32-5"></a>  ni856819231 <span class="ot">&lt;-</span> demote nd163</span>
<span id="cb32-6"><a href="#cb32-6"></a>  withRoots(ni856819231)</span>
<span id="cb32-7"><a href="#cb32-7"></a>    nd168 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">?::</span><span class="dt">I</span> <span class="op">?::</span><span class="dt">I</span>)</span>
<span id="cb32-8"><a href="#cb32-8"></a>    ni220263216 <span class="ot">&lt;-</span> demote nd168</span>
<span id="cb32-9"><a href="#cb32-9"></a>    overwrite ni856819231 (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">&amp;</span>(<span class="dt">CJhc.Type.Word.Int</span> <span class="dv">1</span>) ni220263216)</span>
<span id="cb32-10"><a href="#cb32-10"></a>    withRoots(ni220263216)</span>
<span id="cb32-11"><a href="#cb32-11"></a>      ni144627460 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.</span>Basics.zipWith <span class="op">?::</span><span class="dt">I</span> <span class="op">?::</span><span class="dt">I</span>)</span>
<span id="cb32-12"><a href="#cb32-12"></a>      overwrite ni144627460 (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.</span>Basics.zipWith ni856819231 ni220263216)</span>
<span id="cb32-13"><a href="#cb32-13"></a>      overwrite ni220263216 (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">&amp;</span>(<span class="dt">CJhc.Type.Word.Int</span> <span class="dv">1</span>) ni144627460)</span>
<span id="cb32-14"><a href="#cb32-14"></a>      nd100014 <span class="ot">&lt;-</span> fW<span class="op">@.</span>fR<span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">List</span><span class="op">.</span><span class="dv">387</span>_f <span class="dv">40</span> ni856819231</span>
<span id="cb32-15"><a href="#cb32-15"></a>      ni78 <span class="ot">&lt;-</span> <span class="kw">case</span> nd100014 <span class="kw">of</span></span>
<span id="cb32-16"><a href="#cb32-16"></a>        (<span class="op">CJhc.Prim.Prim.:</span> ni129 ni32) <span class="ot">-&gt;</span> withRoots(ni32,ni129)</span>
<span id="cb32-17"><a href="#cb32-17"></a>          ni194635134 <span class="ot">&lt;-</span> istore (<span class="dt">FR</span><span class="op">@.</span>fJhc<span class="op">.</span><span class="dt">Show</span><span class="op">.</span><span class="dv">11</span>_showl ni32 [])</span>
<span id="cb32-18"><a href="#cb32-18"></a>          withRoots(ni194635134)</span>
<span id="cb32-19"><a href="#cb32-19"></a>            ni196335306 <span class="ot">&lt;-</span> istore (FJhc.Show.shows ni129 ni194635134)</span>
<span id="cb32-20"><a href="#cb32-20"></a>            withRoots(ni196335306)</span>
<span id="cb32-21"><a href="#cb32-21"></a>              nd84 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">&amp;</span>(<span class="dt">CJhc.Type.Basic.Char</span> <span class="dv">91</span>) ni196335306)</span>
<span id="cb32-22"><a href="#cb32-22"></a>              demote nd84</span>
<span id="cb32-23"><a href="#cb32-23"></a>        [] <span class="ot">-&gt;</span> <span class="fu">return</span> ni<span class="op">-</span><span class="dv">930757141</span></span>
<span id="cb32-24"><a href="#cb32-24"></a>      nd100016 <span class="ot">&lt;-</span> eval ni78</span>
<span id="cb32-25"><a href="#cb32-25"></a>      ni81465164 <span class="ot">&lt;-</span> demote nd100016</span>
<span id="cb32-26"><a href="#cb32-26"></a>      nd0 <span class="ot">&lt;-</span> <span class="kw">let</span></span>
<span id="cb32-27"><a href="#cb32-27"></a>          fJhc<span class="op">.</span><span class="dt">Monad</span><span class="op">.</span><span class="dv">72</span>_go ni10 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-28"><a href="#cb32-28"></a>            nd100020 <span class="ot">&lt;-</span> eval ni10</span>
<span id="cb32-29"><a href="#cb32-29"></a>            <span class="kw">case</span> nd100020 <span class="kw">of</span></span>
<span id="cb32-30"><a href="#cb32-30"></a>              (<span class="op">CJhc.Prim.Prim.:</span> ni12 ni260952206) <span class="ot">-&gt;</span> withRoots(ni260952206)</span>
<span id="cb32-31"><a href="#cb32-31"></a>                nd100022 <span class="ot">&lt;-</span> eval ni12</span>
<span id="cb32-32"><a href="#cb32-32"></a>                (<span class="dt">CJhc.Type.Basic.Char</span> w216085086) <span class="ot">&lt;-</span> <span class="fu">return</span> nd100022</span>
<span id="cb32-33"><a href="#cb32-33"></a>                w249143450 <span class="ot">&lt;-</span> (bits32)<span class="dt">ConvOp</span> <span class="dt">B2B</span> bits32 w216085086</span>
<span id="cb32-34"><a href="#cb32-34"></a>                (void)jhc_utf8_putchar(int) w249143450</span>
<span id="cb32-35"><a href="#cb32-35"></a>                fJhc<span class="op">.</span><span class="dt">Monad</span><span class="op">.</span><span class="dv">72</span>_go ni260952206</span>
<span id="cb32-36"><a href="#cb32-36"></a>              [] <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">CJhc.Prim.Prim</span><span class="op">.</span>())</span>
<span id="cb32-37"><a href="#cb32-37"></a>       <span class="kw">in</span></span>
<span id="cb32-38"><a href="#cb32-38"></a>        fJhc<span class="op">.</span><span class="dt">Monad</span><span class="op">.</span><span class="dv">72</span>_go ni81465164</span>
<span id="cb32-39"><a href="#cb32-39"></a>      (void)jhc_utf8_putchar(int) <span class="dv">10</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1"></a><span class="co">/* C言語 */</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="dt">static</span> <span class="dt">void</span> A_STD</span>
<span id="cb33-3"><a href="#cb33-3"></a>ftheMain(gc_t gc)</span>
<span id="cb33-4"><a href="#cb33-4"></a>{</span>
<span id="cb33-5"><a href="#cb33-5"></a>        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd163 &lt;- dstore (CJhc.Prim.Prim.: ?::I ?::I)</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>        wptr_t v163 = x19; <span class="co">// なんで置き換えた？？？</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>        sptr_t v856819231 = demote(v163); <span class="co">// ni856819231 &lt;- demote nd163</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>        {   gc_frame0(gc,<span class="dv">1</span>,v856819231); <span class="co">// withRoots(ni856819231)</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd168 &lt;- dstore (CJhc.Prim.Prim.: ?::I ?::I)</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>            wptr_t v168 = x20;</span>
<span id="cb33-11"><a href="#cb33-11"></a>            sptr_t v220263216 = demote(v168); <span class="co">// ni220263216 &lt;- demote nd168</span></span>
<span id="cb33-12"><a href="#cb33-12"></a>            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a1 = c3; <span class="co">// overwrite ni856819231 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni220263216)</span></span>
<span id="cb33-13"><a href="#cb33-13"></a>            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a2 = v220263216;</span>
<span id="cb33-14"><a href="#cb33-14"></a>            {   sptr_t v10;</span>
<span id="cb33-15"><a href="#cb33-15"></a>                wptr_t v100014;</span>
<span id="cb33-16"><a href="#cb33-16"></a>                sptr_t v78;</span>
<span id="cb33-17"><a href="#cb33-17"></a>                gc_frame0(gc,<span class="dv">1</span>,v220263216); <span class="co">// withRoots(ni220263216)</span></span>
<span id="cb33-18"><a href="#cb33-18"></a>                sptr_t x21 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); <span class="co">// ni144627460 &lt;- istore (FR@.fJhc.Basics.zipWith ?::I ?::I)</span></span>
<span id="cb33-19"><a href="#cb33-19"></a>                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)x21)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith);</span>
<span id="cb33-20"><a href="#cb33-20"></a>                sptr_t v144627460 = MKLAZY(x21);</span>
<span id="cb33-21"><a href="#cb33-21"></a>                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Basics_zipWith); <span class="co">// overwrite ni144627460 (FR@.fJhc.Basics.zipWith ni856819231 ni220263216)</span></span>
<span id="cb33-22"><a href="#cb33-22"></a>                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;a1 = v856819231;</span>
<span id="cb33-23"><a href="#cb33-23"></a>                ((<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))-&gt;a2 = v220263216;</span>
<span id="cb33-24"><a href="#cb33-24"></a>                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))-&gt;a1 = c3; <span class="co">// overwrite ni220263216 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni144627460)</span></span>
<span id="cb33-25"><a href="#cb33-25"></a>                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))-&gt;a2 = v144627460;</span>
<span id="cb33-26"><a href="#cb33-26"></a>                v100014 = fW$__fR$__fJhc_List_387__f(gc,<span class="dv">40</span>,v856819231); <span class="co">// nd100014 &lt;- fW@.fR@.fJhc.List.387_f 40 ni856819231</span></span>
<span id="cb33-27"><a href="#cb33-27"></a>                <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100014) { <span class="co">// ni78 &lt;- case nd100014 of [] -&gt;</span></span>
<span id="cb33-28"><a href="#cb33-28"></a>                    v78 = g930757141; <span class="co">// return ni-930757141</span></span>
<span id="cb33-29"><a href="#cb33-29"></a>                } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni129 ni32) -&gt;</span></span>
<span id="cb33-30"><a href="#cb33-30"></a>                    sptr_t v129;</span>
<span id="cb33-31"><a href="#cb33-31"></a>                    sptr_t v32;</span>
<span id="cb33-32"><a href="#cb33-32"></a>                    <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni129 ni32) パターンマッチ */</span></span>
<span id="cb33-33"><a href="#cb33-33"></a>                    v129 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100014)-&gt;a1;</span>
<span id="cb33-34"><a href="#cb33-34"></a>                    v32 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100014)-&gt;a2;</span>
<span id="cb33-35"><a href="#cb33-35"></a>                    {   gc_frame0(gc,<span class="dv">2</span>,v32,v129); <span class="co">// withRoots(ni32,ni129)</span></span>
<span id="cb33-36"><a href="#cb33-36"></a>                        sptr_t x22 = s_alloc(gc,cFR$__fJhc_Show_11__showl); <span class="co">// ni194635134 &lt;- istore (FR@.fJhc.Show.11_showl ni32 [])</span></span>
<span id="cb33-37"><a href="#cb33-37"></a>                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;head = TO_FPTR(&amp;E__fR$__fJhc_Show_11__showl);</span>
<span id="cb33-38"><a href="#cb33-38"></a>                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;a1 = v32;</span>
<span id="cb33-39"><a href="#cb33-39"></a>                        ((<span class="kw">struct</span> sFR$__fJhc_Show_11__showl*)x22)-&gt;a2 = SET_RAW_TAG(CJhc_Prim_Prim_$BE);</span>
<span id="cb33-40"><a href="#cb33-40"></a>                        sptr_t v194635134 = MKLAZY(x22);</span>
<span id="cb33-41"><a href="#cb33-41"></a>                        {   gc_frame0(gc,<span class="dv">1</span>,v194635134); <span class="co">// withRoots(ni194635134)</span></span>
<span id="cb33-42"><a href="#cb33-42"></a>                            sptr_t x23 = s_alloc(gc,cFJhc_Show_shows); <span class="co">// ni196335306 &lt;- istore (FJhc.Show.shows ni129 ni194635134)</span></span>
<span id="cb33-43"><a href="#cb33-43"></a>                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;head = TO_FPTR(&amp;E__fJhc_Show_shows);</span>
<span id="cb33-44"><a href="#cb33-44"></a>                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;a1 = v129;</span>
<span id="cb33-45"><a href="#cb33-45"></a>                            ((<span class="kw">struct</span> sFJhc_Show_shows*)x23)-&gt;a2 = v194635134;</span>
<span id="cb33-46"><a href="#cb33-46"></a>                            sptr_t v196335306 = MKLAZY(x23);</span>
<span id="cb33-47"><a href="#cb33-47"></a>                            {   gc_frame0(gc,<span class="dv">1</span>,v196335306); <span class="co">// withRoots(ni196335306)</span></span>
<span id="cb33-48"><a href="#cb33-48"></a>                                wptr_t x24 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// nd84 &lt;- dstore (CJhc.Prim.Prim.: &amp;(CJhc.Type.Basic.Char 91) ni196335306)</span></span>
<span id="cb33-49"><a href="#cb33-49"></a>                                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x24)-&gt;a1 = ((sptr_t)RAW_SET_UF(<span class="ch">'['</span>));</span>
<span id="cb33-50"><a href="#cb33-50"></a>                                ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)x24)-&gt;a2 = v196335306;</span>
<span id="cb33-51"><a href="#cb33-51"></a>                                wptr_t v84 = x24;</span>
<span id="cb33-52"><a href="#cb33-52"></a>                                v78 = demote(v84); <span class="co">// demote nd84</span></span>
<span id="cb33-53"><a href="#cb33-53"></a>                            }</span>
<span id="cb33-54"><a href="#cb33-54"></a>                        }</span>
<span id="cb33-55"><a href="#cb33-55"></a>                    }</span>
<span id="cb33-56"><a href="#cb33-56"></a>                }</span>
<span id="cb33-57"><a href="#cb33-57"></a>                wptr_t v100016 = eval(gc,v78); <span class="co">// nd100016 &lt;- eval ni78</span></span>
<span id="cb33-58"><a href="#cb33-58"></a>                sptr_t v81465164 = demote(v100016); <span class="co">// ni81465164 &lt;- demote nd100016</span></span>
<span id="cb33-59"><a href="#cb33-59"></a>                v10 = v81465164; <span class="co">// in fJhc.Monad.72_go ni81465164</span></span>
<span id="cb33-60"><a href="#cb33-60"></a>                fJhc_Monad_72__go__25:; <span class="co">// let fJhc.Monad.72_go ni10 = do</span></span>
<span id="cb33-61"><a href="#cb33-61"></a>                {   wptr_t v100020 = eval(gc,v10); <span class="co">// nd100020 &lt;- eval ni10</span></span>
<span id="cb33-62"><a href="#cb33-62"></a>                    <span class="cf">if</span> (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100020) { <span class="co">// case nd100020 of [] -&gt;</span></span>
<span id="cb33-63"><a href="#cb33-63"></a>                        SET_RAW_TAG(CJhc_Prim_Prim_$LR); <span class="co">// return (CJhc.Prim.Prim.())</span></span>
<span id="cb33-64"><a href="#cb33-64"></a>                    } <span class="cf">else</span> { <span class="co">// (CJhc.Prim.Prim.: ni12 ni260952206) -&gt;</span></span>
<span id="cb33-65"><a href="#cb33-65"></a>                        sptr_t v12;</span>
<span id="cb33-66"><a href="#cb33-66"></a>                        sptr_t v260952206;</span>
<span id="cb33-67"><a href="#cb33-67"></a>                        <span class="co">/* (&quot;CJhc.Prim.Prim.:&quot; ni12 ni260952206) パターンマッチ */</span></span>
<span id="cb33-68"><a href="#cb33-68"></a>                        v12 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100020)-&gt;a1;</span>
<span id="cb33-69"><a href="#cb33-69"></a>                        v260952206 = ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)v100020)-&gt;a2;</span>
<span id="cb33-70"><a href="#cb33-70"></a>                        {   <span class="dt">uint32_t</span> v216085086;</span>
<span id="cb33-71"><a href="#cb33-71"></a>                            gc_frame0(gc,<span class="dv">1</span>,v260952206); <span class="co">// withRoots(ni260952206)</span></span>
<span id="cb33-72"><a href="#cb33-72"></a>                            wptr_t v100022 = eval(gc,v12); <span class="co">// nd100022 &lt;- eval ni12</span></span>
<span id="cb33-73"><a href="#cb33-73"></a>                            v216085086 = ((<span class="dt">uint32_t</span>)RAW_GET_UF(v100022)); <span class="co">// (CJhc.Type.Basic.Char w216085086) &lt;- return nd100022</span></span>
<span id="cb33-74"><a href="#cb33-74"></a>                            <span class="dt">uint32_t</span> v249143450 = v216085086; <span class="co">// w249143450 &lt;- (bits32)ConvOp B2B bits32 w216085086</span></span>
<span id="cb33-75"><a href="#cb33-75"></a>                            saved_gc = gc; <span class="co">// なにこれ？</span></span>
<span id="cb33-76"><a href="#cb33-76"></a>                            (<span class="dt">void</span>)jhc_utf8_putchar((<span class="dt">int</span>)v249143450); <span class="co">// (void)jhc_utf8_putchar(int) w249143450</span></span>
<span id="cb33-77"><a href="#cb33-77"></a>                            v10 = v260952206; <span class="co">// fJhc.Monad.72_go ni260952206</span></span>
<span id="cb33-78"><a href="#cb33-78"></a>                            <span class="cf">goto</span> fJhc_Monad_72__go__25;</span>
<span id="cb33-79"><a href="#cb33-79"></a>                        }</span>
<span id="cb33-80"><a href="#cb33-80"></a>                    }</span>
<span id="cb33-81"><a href="#cb33-81"></a>                }</span>
<span id="cb33-82"><a href="#cb33-82"></a>                saved_gc = gc; <span class="co">// なにこれ？</span></span>
<span id="cb33-83"><a href="#cb33-83"></a>                <span class="cf">return</span> (<span class="dt">void</span>)jhc_utf8_putchar((<span class="dt">int</span>)<span class="dv">10</span>); <span class="co">// (void)jhc_utf8_putchar(int) 10</span></span>
<span id="cb33-84"><a href="#cb33-84"></a>            }</span>
<span id="cb33-85"><a href="#cb33-85"></a>        }</span>
<span id="cb33-86"><a href="#cb33-86"></a>}</span></code></pre></div>
<p>overwriteという不吉なキーワードはなんでゲソ？ “overwrite ni856819231 (CJhc.Prim.Prim.: &amp;(CJhc.Type.Word.Int 1) ni220263216)”に着目すると、 元のコードは…</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>  nd163 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">?::</span><span class="dt">I</span> <span class="op">?::</span><span class="dt">I</span>)</span>
<span id="cb34-2"><a href="#cb34-2"></a>  ni856819231 <span class="ot">&lt;-</span> demote nd163 <span class="op">//</span> 一度目の束縛</span>
<span id="cb34-3"><a href="#cb34-3"></a>  withRoots(ni856819231)</span>
<span id="cb34-4"><a href="#cb34-4"></a>    nd168 <span class="ot">&lt;-</span> dstore (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">?::</span><span class="dt">I</span> <span class="op">?::</span><span class="dt">I</span>)</span>
<span id="cb34-5"><a href="#cb34-5"></a>    ni220263216 <span class="ot">&lt;-</span> demote nd168</span>
<span id="cb34-6"><a href="#cb34-6"></a>    overwrite ni856819231 (<span class="op">CJhc.Prim.Prim.:</span> <span class="op">&amp;</span>(<span class="dt">CJhc.Type.Word.Int</span> <span class="dv">1</span>) ni220263216) <span class="op">//</span> 二度目の束縛</span></code></pre></div>
<p>これがC言語に変換されると…</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1"></a>        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// スマートポインタを埋めずallocだけ</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>        wptr_t v163 = x19;</span>
<span id="cb35-3"><a href="#cb35-3"></a>        sptr_t v856819231 = demote(v163); <span class="co">// 一度目のスマートポインタ代入</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>        {   gc_frame0(gc,<span class="dv">1</span>,v856819231);</span>
<span id="cb35-5"><a href="#cb35-5"></a>            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); <span class="co">// a2に入れるスマートポインタをalloc</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>            wptr_t v168 = x20;</span>
<span id="cb35-7"><a href="#cb35-7"></a>            sptr_t v220263216 = demote(v168);</span>
<span id="cb35-8"><a href="#cb35-8"></a>            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a1 = c3; <span class="co">// alloc済みスマートポインタに代入</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>            ((<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))-&gt;a2 = v220263216;</span></code></pre></div>
<p>ということはoverwriteキーワードはdstoreなどと異なりヒープ領域を確保せず、 第一引数で指定されたスマートポインタを上書きすると考えられるじゃなイカ。 なんとなく上記の例ではoverwriteを使わず一回のdstoreにしてしまっても問題なさそうでゲソが、 コンストラクタと初期化を分割したり、再帰の中で次々に値を更新して結果を得たい場合などに重宝しそうでゲソ。</p>
<p>もう一つ気になるのは“saved_gc = gc”でゲソ。Grinにはなかった行がC言語にいきなり現われるでゲソ… saved_gcはb__main関数から第一引数として取り回されるので、 同じものだと思っていたでゲソ。ここはよくわからなかったでゲソ。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1"></a><span class="dt">void</span> </span>
<span id="cb36-2"><a href="#cb36-2"></a>_amain(<span class="dt">void</span>)</span>
<span id="cb36-3"><a href="#cb36-3"></a>{</span>
<span id="cb36-4"><a href="#cb36-4"></a>        <span class="cf">return</span> (<span class="dt">void</span>)b__main(saved_gc);</span>
<span id="cb36-5"><a href="#cb36-5"></a>}</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="dt">static</span> <span class="dt">void</span> A_STD</span>
<span id="cb36-8"><a href="#cb36-8"></a>b__main(gc_t gc)</span>
<span id="cb36-9"><a href="#cb36-9"></a>{</span>
<span id="cb36-10"><a href="#cb36-10"></a>        <span class="cf">return</span> ftheMain(gc);</span>
<span id="cb36-11"><a href="#cb36-11"></a>}</span></code></pre></div>
<h3 id="grin由来ではないc言語コード">Grin由来ではないC言語コード</h3>
<p>さて。Grinの関数がC言語にどう変換されたか見てきたでゲソ。 でも、とりこぼした要素はないか気にならなイカ？ チェックでゲソ!</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">enum</span> {</span>
<span id="cb37-2"><a href="#cb37-2"></a>    CJhc_Prim_Prim_$BE = <span class="dv">1</span>,</span>
<span id="cb37-3"><a href="#cb37-3"></a>    CJhc_Prim_Prim_$LR = <span class="dv">0</span>,</span>
<span id="cb37-4"><a href="#cb37-4"></a>    CJhc_Prim_Prim_$x3a = <span class="dv">0</span>,</span>
<span id="cb37-5"><a href="#cb37-5"></a>    CJhc_Type_Basic_Char = <span class="dv">0</span>,</span>
<span id="cb37-6"><a href="#cb37-6"></a>    CJhc_Type_Word_Int = <span class="dv">0</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>};</span></code></pre></div>
<p>このenumは有意に使われるのは CJhc_Prim_Prim_$BE だけで、 残りは全く使われていないでゲソ。</p>
<p>CJhc_Prim_Prim_$BE はこれまで見た通り、 リストの終端である [] を表わしていたでゲソ。 どこからでも参照され、中身のない要素はこのようにenumで表わされるようでゲソ。 …しかし16bitしか幅がないので、場合によっては足りなく… ってそんなにNilみたいな要素をばかすか作りっこないでゲッソ。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">struct</span> sCJhc_Prim_Prim_$x3a {</span>
<span id="cb38-2"><a href="#cb38-2"></a>    sptr_t a1;</span>
<span id="cb38-3"><a href="#cb38-3"></a>    sptr_t a2;</span>
<span id="cb38-4"><a href="#cb38-4"></a>};</span>
<span id="cb38-5"><a href="#cb38-5"></a></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="kw">struct</span> sCJhc_Type_Word_Int {</span>
<span id="cb38-7"><a href="#cb38-7"></a>    <span class="dt">uint32_t</span> a1;</span>
<span id="cb38-8"><a href="#cb38-8"></a>};</span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a><span class="kw">struct</span> sFJhc_Show_shows {</span>
<span id="cb38-11"><a href="#cb38-11"></a>    fptr_t head;</span>
<span id="cb38-12"><a href="#cb38-12"></a>    sptr_t a1;</span>
<span id="cb38-13"><a href="#cb38-13"></a>    sptr_t a2;</span>
<span id="cb38-14"><a href="#cb38-14"></a>};</span>
<span id="cb38-15"><a href="#cb38-15"></a></span>
<span id="cb38-16"><a href="#cb38-16"></a><span class="kw">struct</span> sFR$__fJhc_Basics_$pp {</span>
<span id="cb38-17"><a href="#cb38-17"></a>    fptr_t head;</span>
<span id="cb38-18"><a href="#cb38-18"></a>    sptr_t a1;</span>
<span id="cb38-19"><a href="#cb38-19"></a>    wptr_t a2;</span>
<span id="cb38-20"><a href="#cb38-20"></a>};</span>
<span id="cb38-21"><a href="#cb38-21"></a></span>
<span id="cb38-22"><a href="#cb38-22"></a><span class="kw">struct</span> sFR$__fJhc_Basics_zipWith {</span>
<span id="cb38-23"><a href="#cb38-23"></a>    fptr_t head;</span>
<span id="cb38-24"><a href="#cb38-24"></a>    sptr_t a1;</span>
<span id="cb38-25"><a href="#cb38-25"></a>    sptr_t a2;</span>
<span id="cb38-26"><a href="#cb38-26"></a>};</span>
<span id="cb38-27"><a href="#cb38-27"></a></span>
<span id="cb38-28"><a href="#cb38-28"></a><span class="kw">struct</span> sFR$__fJhc_Show_11__showl {</span>
<span id="cb38-29"><a href="#cb38-29"></a>    fptr_t head;</span>
<span id="cb38-30"><a href="#cb38-30"></a>    sptr_t a1;</span>
<span id="cb38-31"><a href="#cb38-31"></a>    wptr_t a2;</span>
<span id="cb38-32"><a href="#cb38-32"></a>};</span>
<span id="cb38-33"><a href="#cb38-33"></a></span>
<span id="cb38-34"><a href="#cb38-34"></a><span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord {</span>
<span id="cb38-35"><a href="#cb38-35"></a>    fptr_t head;</span>
<span id="cb38-36"><a href="#cb38-36"></a>    sptr_t a2;</span>
<span id="cb38-37"><a href="#cb38-37"></a>    <span class="dt">uint32_t</span> a1;</span>
<span id="cb38-38"><a href="#cb38-38"></a>};</span>
<span id="cb38-39"><a href="#cb38-39"></a></span>
<span id="cb38-40"><a href="#cb38-40"></a><span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f {</span>
<span id="cb38-41"><a href="#cb38-41"></a>    fptr_t head;</span>
<span id="cb38-42"><a href="#cb38-42"></a>    sptr_t a2;</span>
<span id="cb38-43"><a href="#cb38-43"></a>    <span class="dt">uint32_t</span> a1;</span>
<span id="cb38-44"><a href="#cb38-44"></a>};</span>
<span id="cb38-45"><a href="#cb38-45"></a></span>
<span id="cb38-46"><a href="#cb38-46"></a><span class="kw">struct</span> sFtheMain$d2 {</span>
<span id="cb38-47"><a href="#cb38-47"></a>    fptr_t head;</span>
<span id="cb38-48"><a href="#cb38-48"></a>    sptr_t a1;</span>
<span id="cb38-49"><a href="#cb38-49"></a>    sptr_t a2;</span>
<span id="cb38-50"><a href="#cb38-50"></a>};</span>
<span id="cb38-51"><a href="#cb38-51"></a></span>
<span id="cb38-52"><a href="#cb38-52"></a><span class="kw">struct</span> sFtheMain$d3 {</span>
<span id="cb38-53"><a href="#cb38-53"></a>    fptr_t head;</span>
<span id="cb38-54"><a href="#cb38-54"></a>};</span></code></pre></div>
<p>これらのstructはこれまで見てきた通り、ヒープに確保される要素群でゲソ。 特にstructの先頭メンバーがfptr_tになっているstructはサンクでゲソ。 structのメンバーを見ればサンクかどうか分かるのは fptr_tを特別なスマートポインタとして扱っている恩恵でゲッソー。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1"></a><span class="dt">void</span> </span>
<span id="cb39-2"><a href="#cb39-2"></a>jhc_hs_init(<span class="dt">void</span>)</span>
<span id="cb39-3"><a href="#cb39-3"></a>{</span>
<span id="cb39-4"><a href="#cb39-4"></a>        find_cache(&amp;cCJhc_Prim_Prim_$x3a,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Prim_Prim_$x3a)),<span class="dv">2</span>);</span>
<span id="cb39-5"><a href="#cb39-5"></a>        find_cache(&amp;cCJhc_Type_Word_Int,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sCJhc_Type_Word_Int)),<span class="dv">0</span>);</span>
<span id="cb39-6"><a href="#cb39-6"></a>        find_cache(&amp;cFW$__fR$__fJhc_List_387__f,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f)),<span class="dv">2</span>);</span>
<span id="cb39-7"><a href="#cb39-7"></a>        find_cache(&amp;cFR$__fJhc_Basics_zipWith,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith)),<span class="dv">3</span>);</span>
<span id="cb39-8"><a href="#cb39-8"></a>        find_cache(&amp;cFR$__fJhc_Basics_$pp,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Basics_$pp)),<span class="dv">3</span>);</span>
<span id="cb39-9"><a href="#cb39-9"></a>        find_cache(&amp;cFtheMain$d2,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFtheMain$d2)),<span class="dv">3</span>);</span>
<span id="cb39-10"><a href="#cb39-10"></a>        find_cache(&amp;cFR$__fJhc_Show_11__showl,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFR$__fJhc_Show_11__showl)),<span class="dv">3</span>);</span>
<span id="cb39-11"><a href="#cb39-11"></a>        find_cache(&amp;cFJhc_Show_shows,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFJhc_Show_shows)),<span class="dv">3</span>);</span>
<span id="cb39-12"><a href="#cb39-12"></a>        find_cache(&amp;cFW$__fJhc_Inst_Show_showWord,arena,TO_BLOCKS(<span class="kw">sizeof</span>(<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord)),<span class="dv">2</span>);</span>
<span id="cb39-13"><a href="#cb39-13"></a>}</span></code></pre></div>
<p>このjhc_hs_init関数はHaskellのRTSを初期化するお約束のhs_init関数から呼び出されるようでゲソ。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1"></a><span class="dt">void</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>hs_init(<span class="dt">int</span> *argc, <span class="dt">char</span> **argv[])</span>
<span id="cb40-3"><a href="#cb40-3"></a>{</span>
<span id="cb40-4"><a href="#cb40-4"></a>        <span class="cf">if</span>(!hs_init_count++) {</span>
<span id="cb40-5"><a href="#cb40-5"></a>                jhc_alloc_init();</span>
<span id="cb40-6"><a href="#cb40-6"></a>                jhc_hs_init();</span></code></pre></div>
<p>find_cache関数とは何者なのでゲソ？</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">struct</span> s_cache *</span>
<span id="cb41-2"><a href="#cb41-2"></a>find_cache(<span class="kw">struct</span> s_cache **rsc, <span class="kw">struct</span> s_arena *arena,</span>
<span id="cb41-3"><a href="#cb41-3"></a>           <span class="dt">unsigned</span> <span class="dt">short</span> size, <span class="dt">unsigned</span> <span class="dt">short</span> num_ptrs)</span>
<span id="cb41-4"><a href="#cb41-4"></a>{</span>
<span id="cb41-5"><a href="#cb41-5"></a>        <span class="cf">if</span>(__predict_true(rsc &amp;&amp; *rsc))</span>
<span id="cb41-6"><a href="#cb41-6"></a>                <span class="cf">return</span> *rsc;</span>
<span id="cb41-7"><a href="#cb41-7"></a>        <span class="kw">struct</span> s_cache *sc = SLIST_FIRST(&amp;arena-&gt;caches);</span>
<span id="cb41-8"><a href="#cb41-8"></a>        <span class="cf">for</span>(;sc;sc = SLIST_NEXT(sc,next)) {</span>
<span id="cb41-9"><a href="#cb41-9"></a>                <span class="cf">if</span>(sc-&gt;size == size &amp;&amp; sc-&gt;num_ptrs == num_ptrs)</span>
<span id="cb41-10"><a href="#cb41-10"></a>                        <span class="cf">goto</span> found;</span>
<span id="cb41-11"><a href="#cb41-11"></a>        }</span>
<span id="cb41-12"><a href="#cb41-12"></a>        sc = new_cache(arena,size,num_ptrs);</span>
<span id="cb41-13"><a href="#cb41-13"></a>found:</span>
<span id="cb41-14"><a href="#cb41-14"></a>        <span class="cf">if</span>(rsc)</span>
<span id="cb41-15"><a href="#cb41-15"></a>                *rsc = sc;</span>
<span id="cb41-16"><a href="#cb41-16"></a>        <span class="cf">return</span> sc;</span>
<span id="cb41-17"><a href="#cb41-17"></a>}</span>
<span id="cb41-18"><a href="#cb41-18"></a></span>
<span id="cb41-19"><a href="#cb41-19"></a><span class="kw">struct</span> s_cache *</span>
<span id="cb41-20"><a href="#cb41-20"></a>new_cache(<span class="kw">struct</span> s_arena *arena, <span class="dt">unsigned</span> <span class="dt">short</span> size, <span class="dt">unsigned</span> <span class="dt">short</span> num_ptrs)</span>
<span id="cb41-21"><a href="#cb41-21"></a>{</span>
<span id="cb41-22"><a href="#cb41-22"></a>        <span class="kw">struct</span> s_cache *sc = malloc(<span class="kw">sizeof</span>(*sc));</span>
<span id="cb41-23"><a href="#cb41-23"></a>        memset(sc,<span class="dv">0</span>,<span class="kw">sizeof</span>(*sc));</span>
<span id="cb41-24"><a href="#cb41-24"></a>        sc-&gt;arena = arena;</span>
<span id="cb41-25"><a href="#cb41-25"></a>        sc-&gt;size = size;</span>
<span id="cb41-26"><a href="#cb41-26"></a>        sc-&gt;num_ptrs = num_ptrs;</span>
<span id="cb41-27"><a href="#cb41-27"></a>        sc-&gt;flags = <span class="dv">0</span>;</span>
<span id="cb41-28"><a href="#cb41-28"></a>        <span class="dt">size_t</span> excess = BLOCK_SIZE - <span class="kw">sizeof</span>(<span class="kw">struct</span> s_block);</span>
<span id="cb41-29"><a href="#cb41-29"></a>        sc-&gt;num_entries = (<span class="dv">8</span>*excess) / (<span class="dv">8</span>*<span class="kw">sizeof</span>(<span class="dt">uintptr_t</span>)*size + <span class="dv">1</span>) - <span class="dv">1</span>;</span>
<span id="cb41-30"><a href="#cb41-30"></a>        sc-&gt;color = (<span class="kw">sizeof</span>(<span class="kw">struct</span> s_block) + BITARRAY_SIZE_IN_BYTES(sc-&gt;num_entries) +</span>
<span id="cb41-31"><a href="#cb41-31"></a>                        <span class="kw">sizeof</span>(<span class="dt">uintptr_t</span>) - <span class="dv">1</span>) / <span class="kw">sizeof</span>(<span class="dt">uintptr_t</span>);</span>
<span id="cb41-32"><a href="#cb41-32"></a>        SLIST_INIT(&amp;sc-&gt;blocks);</span>
<span id="cb41-33"><a href="#cb41-33"></a>        SLIST_INIT(&amp;sc-&gt;full_blocks);</span>
<span id="cb41-34"><a href="#cb41-34"></a>        SLIST_INSERT_HEAD(&amp;arena-&gt;caches,sc,next);</span>
<span id="cb41-35"><a href="#cb41-35"></a>        <span class="cf">return</span> sc;</span>
<span id="cb41-36"><a href="#cb41-36"></a>}</span></code></pre></div>
<p>struct s_arenaのcachesメンバーには、 サイズとポインタの数で種類分けされたcacheと呼ばれるエントリが列になっているでゲソ。 find_cache関数の第三引数はサイズ、第四引数はポインタの数で、 呼び元が欲しいcacheが既にcachesメンバーに確保されているのかチェックするのがfind_cache関数のでゲソ。 もし対応するエントリがcachesに入ってなかった場合、 find_cache関数はnew_cache関数を呼び出して新しいエントリを確保するんじゃなイカ。 …でもこのcachesメンバーはコンパイル時に静的に確保してしまうこともできそうなもんでゲソ。 ここらへんは改善できそうでゲソ。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-2"><a href="#cb42-2"></a>E__fJhc_Show_shows(gc_t gc,<span class="kw">struct</span> sFJhc_Show_shows* arg)</span>
<span id="cb42-3"><a href="#cb42-3"></a>{</span>
<span id="cb42-4"><a href="#cb42-4"></a>        {   wptr_t r;</span>
<span id="cb42-5"><a href="#cb42-5"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-6"><a href="#cb42-6"></a>            r = fJhc_Show_shows(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-7"><a href="#cb42-7"></a>            update(arg,r);</span>
<span id="cb42-8"><a href="#cb42-8"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-9"><a href="#cb42-9"></a>        }</span>
<span id="cb42-10"><a href="#cb42-10"></a>}</span>
<span id="cb42-11"><a href="#cb42-11"></a></span>
<span id="cb42-12"><a href="#cb42-12"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-13"><a href="#cb42-13"></a>E__fR$__fJhc_Basics_$pp(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Basics_$pp* arg)</span>
<span id="cb42-14"><a href="#cb42-14"></a>{</span>
<span id="cb42-15"><a href="#cb42-15"></a>        {   wptr_t r;</span>
<span id="cb42-16"><a href="#cb42-16"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-17"><a href="#cb42-17"></a>            r = fR$__fJhc_Basics_$pp(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-18"><a href="#cb42-18"></a>            update(arg,r);</span>
<span id="cb42-19"><a href="#cb42-19"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-20"><a href="#cb42-20"></a>        }</span>
<span id="cb42-21"><a href="#cb42-21"></a>}</span>
<span id="cb42-22"><a href="#cb42-22"></a></span>
<span id="cb42-23"><a href="#cb42-23"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-24"><a href="#cb42-24"></a>E__fR$__fJhc_Basics_zipWith(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Basics_zipWith* arg)</span>
<span id="cb42-25"><a href="#cb42-25"></a>{</span>
<span id="cb42-26"><a href="#cb42-26"></a>        {   wptr_t r;</span>
<span id="cb42-27"><a href="#cb42-27"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-28"><a href="#cb42-28"></a>            r = fR$__fJhc_Basics_zipWith(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-29"><a href="#cb42-29"></a>            update(arg,r);</span>
<span id="cb42-30"><a href="#cb42-30"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-31"><a href="#cb42-31"></a>        }</span>
<span id="cb42-32"><a href="#cb42-32"></a>}</span>
<span id="cb42-33"><a href="#cb42-33"></a></span>
<span id="cb42-34"><a href="#cb42-34"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-35"><a href="#cb42-35"></a>E__fR$__fJhc_Show_11__showl(gc_t gc,<span class="kw">struct</span> sFR$__fJhc_Show_11__showl* arg)</span>
<span id="cb42-36"><a href="#cb42-36"></a>{</span>
<span id="cb42-37"><a href="#cb42-37"></a>        {   wptr_t r;</span>
<span id="cb42-38"><a href="#cb42-38"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-39"><a href="#cb42-39"></a>            r = fR$__fJhc_Show_11__showl(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-40"><a href="#cb42-40"></a>            update(arg,r);</span>
<span id="cb42-41"><a href="#cb42-41"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-42"><a href="#cb42-42"></a>        }</span>
<span id="cb42-43"><a href="#cb42-43"></a>}</span>
<span id="cb42-44"><a href="#cb42-44"></a></span>
<span id="cb42-45"><a href="#cb42-45"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-46"><a href="#cb42-46"></a>E__fW$__fJhc_Inst_Show_showWord(gc_t gc,<span class="kw">struct</span> sFW$__fJhc_Inst_Show_showWord* arg)</span>
<span id="cb42-47"><a href="#cb42-47"></a>{</span>
<span id="cb42-48"><a href="#cb42-48"></a>        {   wptr_t r;</span>
<span id="cb42-49"><a href="#cb42-49"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-50"><a href="#cb42-50"></a>            r = fW$__fJhc_Inst_Show_showWord(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-51"><a href="#cb42-51"></a>            update(arg,r);</span>
<span id="cb42-52"><a href="#cb42-52"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-53"><a href="#cb42-53"></a>        }</span>
<span id="cb42-54"><a href="#cb42-54"></a>}</span>
<span id="cb42-55"><a href="#cb42-55"></a></span>
<span id="cb42-56"><a href="#cb42-56"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-57"><a href="#cb42-57"></a>E__fW$__fR$__fJhc_List_387__f(gc_t gc,<span class="kw">struct</span> sFW$__fR$__fJhc_List_387__f* arg)</span>
<span id="cb42-58"><a href="#cb42-58"></a>{</span>
<span id="cb42-59"><a href="#cb42-59"></a>        {   wptr_t r;</span>
<span id="cb42-60"><a href="#cb42-60"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-61"><a href="#cb42-61"></a>            r = fW$__fR$__fJhc_List_387__f(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-62"><a href="#cb42-62"></a>            update(arg,r);</span>
<span id="cb42-63"><a href="#cb42-63"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-64"><a href="#cb42-64"></a>        }</span>
<span id="cb42-65"><a href="#cb42-65"></a>}</span>
<span id="cb42-66"><a href="#cb42-66"></a></span>
<span id="cb42-67"><a href="#cb42-67"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-68"><a href="#cb42-68"></a>E__ftheMain$d2(gc_t gc,<span class="kw">struct</span> sFtheMain$d2* arg)</span>
<span id="cb42-69"><a href="#cb42-69"></a>{</span>
<span id="cb42-70"><a href="#cb42-70"></a>        {   wptr_t r;</span>
<span id="cb42-71"><a href="#cb42-71"></a>            gc_frame0(gc,<span class="dv">1</span>,MKLAZY(arg));</span>
<span id="cb42-72"><a href="#cb42-72"></a>            r = ftheMain$d2(gc,arg-&gt;a1,arg-&gt;a2);</span>
<span id="cb42-73"><a href="#cb42-73"></a>            update(arg,r);</span>
<span id="cb42-74"><a href="#cb42-74"></a>            <span class="cf">return</span> r;</span>
<span id="cb42-75"><a href="#cb42-75"></a>        }</span>
<span id="cb42-76"><a href="#cb42-76"></a>}</span>
<span id="cb42-77"><a href="#cb42-77"></a></span>
<span id="cb42-78"><a href="#cb42-78"></a><span class="dt">static</span> wptr_t A_STD A_FALIGNED</span>
<span id="cb42-79"><a href="#cb42-79"></a>E__ftheMain$d3(gc_t gc,<span class="kw">struct</span> sFtheMain$d3* arg)</span>
<span id="cb42-80"><a href="#cb42-80"></a>{</span>
<span id="cb42-81"><a href="#cb42-81"></a>        wptr_t r;</span>
<span id="cb42-82"><a href="#cb42-82"></a>        r = ftheMain$d3(gc);</span>
<span id="cb42-83"><a href="#cb42-83"></a>        update(arg,r);</span>
<span id="cb42-84"><a href="#cb42-84"></a>        gc_add_root(gc,(sptr_t)r);</span>
<span id="cb42-85"><a href="#cb42-85"></a>        <span class="cf">return</span> r;</span>
<span id="cb42-86"><a href="#cb42-86"></a>}</span></code></pre></div>
<p>この"E__f"で始まる関数群はほぼ同じことをしているでゲソ。</p>
<ol type="1">
<li>gc_frame0(gc,1,MKLAZY(arg));</li>
<li>関数名から"E__f"プレフィックスを除いた関数を呼び出す</li>
<li>update(arg,r);</li>
<li>return r;</li>
</ol>
<p>まず最初のgc_frame0はイカのようなマクロで、 引数argはポインタで、lazy locationフラグを立ててGCルートに追加するでゲソ。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#define TO_SPTR(t,x)   (typeof (x))((uintptr_t)(x) | (t))</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#define MKLAZY(fn)    TO_SPTR(P_LAZY,(sptr_t)fn)</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="pp">#define gc_frame0(gc,n,...) void *ptrs[n] = { __VA_ARGS__ }; \</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="pp">        for(int i = 0; i &lt; n; i++) gc[i] = (sptr_t)ptrs[i]; \</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="pp">        gc_t sgc = gc;  gc_t gc = sgc + n;</span></span></code></pre></div>
<p>update関数は"E__f"プレフィックスを除いた関数の返値でargのhead、 つまりfptr_tを上書きするでゲソ。 これは未評価サンクの評価を行なっているんじゃなイカ？</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> node {</span>
<span id="cb44-2"><a href="#cb44-2"></a>        fptr_t head;</span>
<span id="cb44-3"><a href="#cb44-3"></a>        sptr_t rest[];</span>
<span id="cb44-4"><a href="#cb44-4"></a>} A_MAYALIAS node_t;</span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="pp">#define NODEP(x)     ((node_t *)(x))</span></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="pp">#define GETHEAD(x)   (NODEP(x)-&gt;head)</span></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="kw">inline</span> <span class="dt">static</span> <span class="dt">void</span> update(<span class="dt">void</span> *t, wptr_t n) { GETHEAD(t) = (fptr_t)n; }</span></code></pre></div>
<p>もう一度、“1. Caf: v-930757141”を振り替えってみるでゲソ。 詳細に図を描いてみたら未評価サンクが評価される動作がはっきり解ったじゃなイカ!</p>
<p><img src="../draw/2013-02-14-jhc_grin_to_c_E__f.png" /></p>
<p>うん。なんとなくGrin=&gt;Cがどんな変換なのかイメージがつかめたでゲソ。 次は例による理解ではなく、jhcのソースコードそのものを理解することもできるんじゃなイカ？</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="http://www.paraiso-lang.org/ikmsm/books/c82.html">簡約!? λカ娘(算) - 参照透明な海を守る会</a> を参照<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<p>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'metasepi';
    var disqus_identifier = '/posts/2013-05-16-jhc_grin_to_c.html';
    var disqus_url = 'https://metasepi.org' + '/posts/2013-05-16-jhc_grin_to_c.html';
    var disqus_title = 'Jhc compile pipeline: Grin => C (code example)';
    var disqus_developer = 1;
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the 
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  <a href="http://disqus.com" class="dsq-brlink">
    blog comments powered by <span.logo-disqus>Disqus</span>
  </a>
</p>

    </div>

    <footer>
      <p>
        This page is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a>
        <br>
        Metasepi project is supported by
        <a href="http://www.metasepi-design.com/"><img alt="METASEPI DESIGN" style="border-width:0" src="../img/metasepi_design_logo_82x25.png" /></a> ×
        <a href="../past-supporters.html">Past Supporters</a>
      </p>
    </footer>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="/js/libs/jquery-1.6.2.min.js"><\/script>')</script>

  <!-- scripts concatenated and minified via ant build script-->
  <script defer src="../js/plugins.js"></script>
  <script defer src="../js/script.js"></script>
  <!-- end scripts-->

  <script>
    window._gaq = [['_setAccount','UA-158383-8'],['_trackPageview'],['_trackPageLoadTime']];
    Modernizr.load({
      load: ('https:' == location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js'
    });
  </script>

  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js">
    <script>
      window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
  <![endif]-->
</body>
